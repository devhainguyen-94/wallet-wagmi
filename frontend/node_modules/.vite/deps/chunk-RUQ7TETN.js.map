{
  "version": 3,
  "sources": ["../../viem/utils/chain/defineChain.ts", "../../viem/utils/formatters/transaction.ts", "../../viem/utils/formatters/block.ts", "../../viem/utils/formatters/log.ts", "../../viem/utils/formatters/transactionReceipt.ts", "../../viem/utils/encoding/toRlp.ts", "../../viem/utils/blob/blobsToCommitments.ts", "../../viem/utils/blob/blobsToProofs.ts", "../../viem/utils/hash/sha256.ts", "../../viem/utils/blob/commitmentToVersionedHash.ts", "../../viem/utils/blob/commitmentsToVersionedHashes.ts", "../../viem/constants/blob.ts", "../../viem/constants/kzg.ts", "../../viem/errors/blob.ts", "../../viem/utils/blob/toBlobs.ts", "../../viem/utils/blob/toBlobSidecars.ts", "../../viem/utils/transaction/assertTransaction.ts", "../../viem/utils/transaction/getTransactionType.ts", "../../viem/utils/transaction/serializeAccessList.ts", "../../viem/utils/authorization/serializeAuthorizationList.ts", "../../viem/utils/transaction/serializeTransaction.ts", "../../viem/utils/chain/assertCurrentChain.ts", "../../viem/utils/chain/extractChain.ts", "../../viem/errors/account.ts"],
  "sourcesContent": ["import type { Chain, ChainFormatters } from '../../types/chain.js'\r\nimport type { Assign, Prettify } from '../../types/utils.js'\r\n\r\nexport function defineChain<\r\n  formatters extends ChainFormatters,\r\n  const chain extends Chain<formatters>,\r\n>(chain: chain): Prettify<Assign<Chain<undefined>, chain>> {\r\n  return {\r\n    formatters: undefined,\r\n    fees: undefined,\r\n    serializers: undefined,\r\n    ...chain,\r\n  } as Assign<Chain<undefined>, chain>\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { SignedAuthorizationList } from '../../types/authorization.js'\r\nimport type { BlockTag } from '../../types/block.js'\r\nimport type { Chain } from '../../types/chain.js'\r\nimport type {\r\n  ExtractChainFormatterExclude,\r\n  ExtractChainFormatterReturnType,\r\n} from '../../types/chain.js'\r\nimport type { Hex } from '../../types/misc.js'\r\nimport type { RpcAuthorizationList, RpcTransaction } from '../../types/rpc.js'\r\nimport type { Transaction, TransactionType } from '../../types/transaction.js'\r\nimport type { ExactPartial, UnionLooseOmit } from '../../types/utils.js'\r\nimport { hexToNumber } from '../encoding/fromHex.js'\r\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\r\n\r\ntype TransactionPendingDependencies =\r\n  | 'blockHash'\r\n  | 'blockNumber'\r\n  | 'transactionIndex'\r\n\r\nexport type FormattedTransaction<\r\n  chain extends Chain | undefined = undefined,\r\n  blockTag extends BlockTag = BlockTag,\r\n  _FormatterReturnType = ExtractChainFormatterReturnType<\r\n    chain,\r\n    'transaction',\r\n    Transaction\r\n  >,\r\n  _ExcludedPendingDependencies extends string = TransactionPendingDependencies &\r\n    ExtractChainFormatterExclude<chain, 'transaction'>,\r\n> = UnionLooseOmit<_FormatterReturnType, TransactionPendingDependencies> & {\r\n  [_K in _ExcludedPendingDependencies]: never\r\n} & Pick<\r\n    Transaction<bigint, number, blockTag extends 'pending' ? true : false>,\r\n    TransactionPendingDependencies\r\n  >\r\n\r\nexport const transactionType = {\r\n  '0x0': 'legacy',\r\n  '0x1': 'eip2930',\r\n  '0x2': 'eip1559',\r\n  '0x3': 'eip4844',\r\n  '0x4': 'eip7702',\r\n} as const satisfies Record<Hex, TransactionType>\r\n\r\nexport type FormatTransactionErrorType = ErrorType\r\n\r\nexport function formatTransaction(transaction: ExactPartial<RpcTransaction>) {\r\n  const transaction_ = {\r\n    ...transaction,\r\n    blockHash: transaction.blockHash ? transaction.blockHash : null,\r\n    blockNumber: transaction.blockNumber\r\n      ? BigInt(transaction.blockNumber)\r\n      : null,\r\n    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,\r\n    gas: transaction.gas ? BigInt(transaction.gas) : undefined,\r\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,\r\n    maxFeePerBlobGas: transaction.maxFeePerBlobGas\r\n      ? BigInt(transaction.maxFeePerBlobGas)\r\n      : undefined,\r\n    maxFeePerGas: transaction.maxFeePerGas\r\n      ? BigInt(transaction.maxFeePerGas)\r\n      : undefined,\r\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\r\n      ? BigInt(transaction.maxPriorityFeePerGas)\r\n      : undefined,\r\n    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,\r\n    to: transaction.to ? transaction.to : null,\r\n    transactionIndex: transaction.transactionIndex\r\n      ? Number(transaction.transactionIndex)\r\n      : null,\r\n    type: transaction.type\r\n      ? (transactionType as any)[transaction.type]\r\n      : undefined,\r\n    typeHex: transaction.type ? transaction.type : undefined,\r\n    value: transaction.value ? BigInt(transaction.value) : undefined,\r\n    v: transaction.v ? BigInt(transaction.v) : undefined,\r\n  } as Transaction\r\n\r\n  if (transaction.authorizationList)\r\n    transaction_.authorizationList = formatAuthorizationList(\r\n      transaction.authorizationList,\r\n    )\r\n\r\n  transaction_.yParity = (() => {\r\n    // If `yParity` is provided, we will use it.\r\n    if (transaction.yParity) return Number(transaction.yParity)\r\n\r\n    // If no `yParity` provided, try derive from `v`.\r\n    if (typeof transaction_.v === 'bigint') {\r\n      if (transaction_.v === 0n || transaction_.v === 27n) return 0\r\n      if (transaction_.v === 1n || transaction_.v === 28n) return 1\r\n      if (transaction_.v >= 35n) return transaction_.v % 2n === 0n ? 1 : 0\r\n    }\r\n\r\n    return undefined\r\n  })()\r\n\r\n  if (transaction_.type === 'legacy') {\r\n    delete transaction_.accessList\r\n    delete transaction_.maxFeePerBlobGas\r\n    delete transaction_.maxFeePerGas\r\n    delete transaction_.maxPriorityFeePerGas\r\n    delete transaction_.yParity\r\n  }\r\n  if (transaction_.type === 'eip2930') {\r\n    delete transaction_.maxFeePerBlobGas\r\n    delete transaction_.maxFeePerGas\r\n    delete transaction_.maxPriorityFeePerGas\r\n  }\r\n  if (transaction_.type === 'eip1559') {\r\n    delete transaction_.maxFeePerBlobGas\r\n  }\r\n  return transaction_\r\n}\r\n\r\nexport type DefineTransactionErrorType = DefineFormatterErrorType | ErrorType\r\n\r\nexport const defineTransaction = /*#__PURE__*/ defineFormatter(\r\n  'transaction',\r\n  formatTransaction,\r\n)\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction formatAuthorizationList(\r\n  authorizationList: RpcAuthorizationList,\r\n): SignedAuthorizationList {\r\n  return authorizationList.map((authorization) => ({\r\n    address: (authorization as any).address,\r\n    chainId: Number(authorization.chainId),\r\n    nonce: Number(authorization.nonce),\r\n    r: authorization.r,\r\n    s: authorization.s,\r\n    yParity: Number(authorization.yParity),\r\n  })) as SignedAuthorizationList\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { Block, BlockTag } from '../../types/block.js'\r\nimport type { Chain } from '../../types/chain.js'\r\nimport type {\r\n  ExtractChainFormatterExclude,\r\n  ExtractChainFormatterReturnType,\r\n} from '../../types/chain.js'\r\nimport type { Hash } from '../../types/misc.js'\r\nimport type { RpcBlock } from '../../types/rpc.js'\r\nimport type { ExactPartial, Prettify } from '../../types/utils.js'\r\n\r\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\r\nimport { type FormattedTransaction, formatTransaction } from './transaction.js'\r\n\r\ntype BlockPendingDependencies = 'hash' | 'logsBloom' | 'nonce' | 'number'\r\n\r\nexport type FormattedBlock<\r\n  chain extends Chain | undefined = undefined,\r\n  includeTransactions extends boolean = boolean,\r\n  blockTag extends BlockTag = BlockTag,\r\n  _FormatterReturnType = ExtractChainFormatterReturnType<\r\n    chain,\r\n    'block',\r\n    Block<bigint, includeTransactions>\r\n  >,\r\n  _ExcludedPendingDependencies extends string = BlockPendingDependencies &\r\n    ExtractChainFormatterExclude<chain, 'block'>,\r\n  _Formatted = Omit<_FormatterReturnType, BlockPendingDependencies> & {\r\n    [_key in _ExcludedPendingDependencies]: never\r\n  } & Pick<\r\n      Block<bigint, includeTransactions, blockTag>,\r\n      BlockPendingDependencies\r\n    >,\r\n  _Transactions = includeTransactions extends true\r\n    ? Prettify<FormattedTransaction<chain, blockTag>>[]\r\n    : Hash[],\r\n> = Omit<_Formatted, 'transactions'> & {\r\n  transactions: _Transactions\r\n}\r\n\r\nexport type FormatBlockErrorType = ErrorType\r\n\r\nexport function formatBlock(block: ExactPartial<RpcBlock>) {\r\n  const transactions = (block.transactions ?? []).map((transaction) => {\r\n    if (typeof transaction === 'string') return transaction\r\n    return formatTransaction(transaction)\r\n  })\r\n  return {\r\n    ...block,\r\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\r\n    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,\r\n    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\r\n    excessBlobGas: block.excessBlobGas\r\n      ? BigInt(block.excessBlobGas)\r\n      : undefined,\r\n    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,\r\n    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,\r\n    hash: block.hash ? block.hash : null,\r\n    logsBloom: block.logsBloom ? block.logsBloom : null,\r\n    nonce: block.nonce ? block.nonce : null,\r\n    number: block.number ? BigInt(block.number) : null,\r\n    size: block.size ? BigInt(block.size) : undefined,\r\n    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,\r\n    transactions,\r\n    totalDifficulty: block.totalDifficulty\r\n      ? BigInt(block.totalDifficulty)\r\n      : null,\r\n  } as Block\r\n}\r\n\r\nexport type DefineBlockErrorType = DefineFormatterErrorType | ErrorType\r\n\r\nexport const defineBlock = /*#__PURE__*/ defineFormatter('block', formatBlock)\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { Log } from '../../types/log.js'\r\nimport type { RpcLog } from '../../types/rpc.js'\r\nimport type { ExactPartial } from '../../types/utils.js'\r\n\r\nexport type FormatLogErrorType = ErrorType\r\n\r\nexport function formatLog(\r\n  log: ExactPartial<RpcLog>,\r\n  {\r\n    args,\r\n    eventName,\r\n  }: { args?: unknown | undefined; eventName?: string | undefined } = {},\r\n) {\r\n  return {\r\n    ...log,\r\n    blockHash: log.blockHash ? log.blockHash : null,\r\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\r\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\r\n    transactionHash: log.transactionHash ? log.transactionHash : null,\r\n    transactionIndex: log.transactionIndex\r\n      ? Number(log.transactionIndex)\r\n      : null,\r\n    ...(eventName ? { args, eventName } : {}),\r\n  } as Log\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type {\r\n  Chain,\r\n  ExtractChainFormatterReturnType,\r\n} from '../../types/chain.js'\r\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\r\nimport type { TransactionReceipt } from '../../types/transaction.js'\r\nimport type { ExactPartial } from '../../types/utils.js'\r\nimport { hexToNumber } from '../encoding/fromHex.js'\r\n\r\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\r\nimport { formatLog } from './log.js'\r\nimport { transactionType } from './transaction.js'\r\n\r\nexport type FormattedTransactionReceipt<\r\n  chain extends Chain | undefined = undefined,\r\n> = ExtractChainFormatterReturnType<\r\n  chain,\r\n  'transactionReceipt',\r\n  TransactionReceipt\r\n>\r\n\r\nexport const receiptStatuses = {\r\n  '0x0': 'reverted',\r\n  '0x1': 'success',\r\n} as const\r\n\r\nexport type FormatTransactionReceiptErrorType = ErrorType\r\n\r\nexport function formatTransactionReceipt(\r\n  transactionReceipt: ExactPartial<RpcTransactionReceipt>,\r\n) {\r\n  const receipt = {\r\n    ...transactionReceipt,\r\n    blockNumber: transactionReceipt.blockNumber\r\n      ? BigInt(transactionReceipt.blockNumber)\r\n      : null,\r\n    contractAddress: transactionReceipt.contractAddress\r\n      ? transactionReceipt.contractAddress\r\n      : null,\r\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\r\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\r\n      : null,\r\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\r\n      ? BigInt(transactionReceipt.effectiveGasPrice)\r\n      : null,\r\n    gasUsed: transactionReceipt.gasUsed\r\n      ? BigInt(transactionReceipt.gasUsed)\r\n      : null,\r\n    logs: transactionReceipt.logs\r\n      ? transactionReceipt.logs.map((log) => formatLog(log))\r\n      : null,\r\n    to: transactionReceipt.to ? transactionReceipt.to : null,\r\n    transactionIndex: transactionReceipt.transactionIndex\r\n      ? hexToNumber(transactionReceipt.transactionIndex)\r\n      : null,\r\n    status: transactionReceipt.status\r\n      ? receiptStatuses[transactionReceipt.status]\r\n      : null,\r\n    type: transactionReceipt.type\r\n      ? transactionType[\r\n          transactionReceipt.type as keyof typeof transactionType\r\n        ] || transactionReceipt.type\r\n      : null,\r\n  } as TransactionReceipt\r\n\r\n  if (transactionReceipt.blobGasPrice)\r\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice)\r\n  if (transactionReceipt.blobGasUsed)\r\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed)\r\n\r\n  return receipt\r\n}\r\n\r\nexport type DefineTransactionReceiptErrorType =\r\n  | DefineFormatterErrorType\r\n  | ErrorType\r\n\r\nexport const defineTransactionReceipt = /*#__PURE__*/ defineFormatter(\r\n  'transactionReceipt',\r\n  formatTransactionReceipt,\r\n)\r\n", "import { BaseError } from '../../errors/base.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport {\r\n  type CreateCursorErrorType,\r\n  type Cursor,\r\n  createCursor,\r\n} from '../cursor.js'\r\n\r\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\r\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\r\n\r\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\ntype Encodable = {\r\n  length: number\r\n  encode(cursor: Cursor): void\r\n}\r\n\r\nexport type ToRlpReturnType<to extends To> =\r\n  | (to extends 'bytes' ? ByteArray : never)\r\n  | (to extends 'hex' ? Hex : never)\r\n\r\nexport type ToRlpErrorType =\r\n  | CreateCursorErrorType\r\n  | BytesToHexErrorType\r\n  | HexToBytesErrorType\r\n  | ErrorType\r\n\r\nexport function toRlp<to extends To = 'hex'>(\r\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\r\n  to: to | To | undefined = 'hex',\r\n): ToRlpReturnType<to> {\r\n  const encodable = getEncodable(bytes)\r\n  const cursor = createCursor(new Uint8Array(encodable.length))\r\n  encodable.encode(cursor)\r\n\r\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\r\n  return cursor.bytes as ToRlpReturnType<to>\r\n}\r\n\r\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\r\n\r\nexport function bytesToRlp<to extends To = 'bytes'>(\r\n  bytes: RecursiveArray<ByteArray>,\r\n  to: to | To | undefined = 'bytes',\r\n): ToRlpReturnType<to> {\r\n  return toRlp(bytes, to)\r\n}\r\n\r\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\r\n\r\nexport function hexToRlp<to extends To = 'hex'>(\r\n  hex: RecursiveArray<Hex>,\r\n  to: to | To | undefined = 'hex',\r\n): ToRlpReturnType<to> {\r\n  return toRlp(hex, to)\r\n}\r\n\r\nfunction getEncodable(\r\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\r\n): Encodable {\r\n  if (Array.isArray(bytes))\r\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\r\n  return getEncodableBytes(bytes as any)\r\n}\r\n\r\nfunction getEncodableList(list: Encodable[]): Encodable {\r\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\r\n\r\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\r\n  const length = (() => {\r\n    if (bodyLength <= 55) return 1 + bodyLength\r\n    return 1 + sizeOfBodyLength + bodyLength\r\n  })()\r\n\r\n  return {\r\n    length,\r\n    encode(cursor: Cursor) {\r\n      if (bodyLength <= 55) {\r\n        cursor.pushByte(0xc0 + bodyLength)\r\n      } else {\r\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\r\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\r\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\r\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\r\n        else cursor.pushUint32(bodyLength)\r\n      }\r\n      for (const { encode } of list) {\r\n        encode(cursor)\r\n      }\r\n    },\r\n  }\r\n}\r\n\r\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\r\n  const bytes =\r\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\r\n\r\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\r\n  const length = (() => {\r\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\r\n    if (bytes.length <= 55) return 1 + bytes.length\r\n    return 1 + sizeOfBytesLength + bytes.length\r\n  })()\r\n\r\n  return {\r\n    length,\r\n    encode(cursor: Cursor) {\r\n      if (bytes.length === 1 && bytes[0] < 0x80) {\r\n        cursor.pushBytes(bytes)\r\n      } else if (bytes.length <= 55) {\r\n        cursor.pushByte(0x80 + bytes.length)\r\n        cursor.pushBytes(bytes)\r\n      } else {\r\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\r\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\r\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\r\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\r\n        else cursor.pushUint32(bytes.length)\r\n        cursor.pushBytes(bytes)\r\n      }\r\n    },\r\n  }\r\n}\r\n\r\nfunction getSizeOfLength(length: number) {\r\n  if (length < 2 ** 8) return 1\r\n  if (length < 2 ** 16) return 2\r\n  if (length < 2 ** 24) return 3\r\n  if (length < 2 ** 32) return 4\r\n  throw new BaseError('Length is too large.')\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { Kzg } from '../../types/kzg.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\r\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type BlobsToCommitmentsParameters<\r\n  blobs extends readonly ByteArray[] | readonly Hex[] =\r\n    | readonly ByteArray[]\r\n    | readonly Hex[],\r\n  to extends To | undefined = undefined,\r\n> = {\r\n  /** Blobs to transform into commitments. */\r\n  blobs: blobs | readonly ByteArray[] | readonly Hex[]\r\n  /** KZG implementation. */\r\n  kzg: Pick<Kzg, 'blobToKzgCommitment'>\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n}\r\n\r\nexport type BlobsToCommitmentsReturnType<to extends To> =\r\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\r\n  | (to extends 'hex' ? readonly Hex[] : never)\r\n\r\nexport type BlobsToCommitmentsErrorType =\r\n  | HexToBytesErrorType\r\n  | BytesToHexErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Compute commitments from a list of blobs.\r\n *\r\n * @example\r\n * ```ts\r\n * import { blobsToCommitments, toBlobs } from 'viem'\r\n * import { kzg } from './kzg'\r\n *\r\n * const blobs = toBlobs({ data: '0x1234' })\r\n * const commitments = blobsToCommitments({ blobs, kzg })\r\n * ```\r\n */\r\nexport function blobsToCommitments<\r\n  const blobs extends readonly ByteArray[] | readonly Hex[],\r\n  to extends To =\r\n    | (blobs extends readonly Hex[] ? 'hex' : never)\r\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\r\n>(\r\n  parameters: BlobsToCommitmentsParameters<blobs, to>,\r\n): BlobsToCommitmentsReturnType<to> {\r\n  const { kzg } = parameters\r\n\r\n  const to =\r\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\r\n  const blobs = (\r\n    typeof parameters.blobs[0] === 'string'\r\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\r\n      : parameters.blobs\r\n  ) as ByteArray[]\r\n\r\n  const commitments: ByteArray[] = []\r\n  for (const blob of blobs)\r\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\r\n\r\n  return (to === 'bytes'\r\n    ? commitments\r\n    : commitments.map((x) =>\r\n        bytesToHex(x),\r\n      )) as {} as BlobsToCommitmentsReturnType<to>\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { Kzg } from '../../types/kzg.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\r\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type blobsToProofsParameters<\r\n  blobs extends readonly ByteArray[] | readonly Hex[],\r\n  commitments extends readonly ByteArray[] | readonly Hex[],\r\n  to extends To =\r\n    | (blobs extends readonly Hex[] ? 'hex' : never)\r\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\r\n  ///\r\n  _blobsType =\r\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\r\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\r\n> = {\r\n  /** Blobs to transform into proofs. */\r\n  blobs: blobs\r\n  /** Commitments for the blobs. */\r\n  commitments: commitments &\r\n    (commitments extends _blobsType\r\n      ? {}\r\n      : `commitments must be the same type as blobs`)\r\n  /** KZG implementation. */\r\n  kzg: Pick<Kzg, 'computeBlobKzgProof'>\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n}\r\n\r\nexport type blobsToProofsReturnType<to extends To> =\r\n  | (to extends 'bytes' ? ByteArray[] : never)\r\n  | (to extends 'hex' ? Hex[] : never)\r\n\r\nexport type blobsToProofsErrorType =\r\n  | BytesToHexErrorType\r\n  | HexToBytesErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Compute the proofs for a list of blobs and their commitments.\r\n *\r\n * @example\r\n * ```ts\r\n * import {\r\n *   blobsToCommitments,\r\n *   toBlobs\r\n * } from 'viem'\r\n * import { kzg } from './kzg'\r\n *\r\n * const blobs = toBlobs({ data: '0x1234' })\r\n * const commitments = blobsToCommitments({ blobs, kzg })\r\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\r\n * ```\r\n */\r\nexport function blobsToProofs<\r\n  const blobs extends readonly ByteArray[] | readonly Hex[],\r\n  const commitments extends readonly ByteArray[] | readonly Hex[],\r\n  to extends To =\r\n    | (blobs extends readonly Hex[] ? 'hex' : never)\r\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\r\n>(\r\n  parameters: blobsToProofsParameters<blobs, commitments, to>,\r\n): blobsToProofsReturnType<to> {\r\n  const { kzg } = parameters\r\n\r\n  const to =\r\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\r\n\r\n  const blobs = (\r\n    typeof parameters.blobs[0] === 'string'\r\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\r\n      : parameters.blobs\r\n  ) as ByteArray[]\r\n  const commitments = (\r\n    typeof parameters.commitments[0] === 'string'\r\n      ? parameters.commitments.map((x) => hexToBytes(x as any))\r\n      : parameters.commitments\r\n  ) as ByteArray[]\r\n\r\n  const proofs: ByteArray[] = []\r\n  for (let i = 0; i < blobs.length; i++) {\r\n    const blob = blobs[i]\r\n    const commitment = commitments[i]\r\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\r\n  }\r\n\r\n  return (to === 'bytes'\r\n    ? proofs\r\n    : proofs.map((x) => bytesToHex(x))) as {} as blobsToProofsReturnType<to>\r\n}\r\n", "import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\r\n\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\r\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\r\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type Sha256Hash<to extends To> =\r\n  | (to extends 'bytes' ? ByteArray : never)\r\n  | (to extends 'hex' ? Hex : never)\r\n\r\nexport type Sha256ErrorType =\r\n  | IsHexErrorType\r\n  | ToBytesErrorType\r\n  | ToHexErrorType\r\n  | ErrorType\r\n\r\nexport function sha256<to extends To = 'hex'>(\r\n  value: Hex | ByteArray,\r\n  to_?: to | undefined,\r\n): Sha256Hash<to> {\r\n  const to = to_ || 'hex'\r\n  const bytes = noble_sha256(\r\n    isHex(value, { strict: false }) ? toBytes(value) : value,\r\n  )\r\n  if (to === 'bytes') return bytes as Sha256Hash<to>\r\n  return toHex(bytes) as Sha256Hash<to>\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\r\nimport { type Sha256ErrorType, sha256 } from '../hash/sha256.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type CommitmentToVersionedHashParameters<\r\n  commitment extends Uint8Array | Hex = Uint8Array | Hex,\r\n  to extends To | undefined = undefined,\r\n> = {\r\n  /** Commitment from blob. */\r\n  commitment: commitment | Uint8Array | Hex\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n  /** Version to tag onto the hash. */\r\n  version?: number | undefined\r\n}\r\n\r\nexport type CommitmentToVersionedHashReturnType<to extends To> =\r\n  | (to extends 'bytes' ? ByteArray : never)\r\n  | (to extends 'hex' ? Hex : never)\r\n\r\nexport type CommitmentToVersionedHashErrorType =\r\n  | Sha256ErrorType\r\n  | BytesToHexErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Transform a commitment to it's versioned hash.\r\n *\r\n * @example\r\n * ```ts\r\n * import {\r\n *   blobsToCommitments,\r\n *   commitmentToVersionedHash,\r\n *   toBlobs\r\n * } from 'viem'\r\n * import { kzg } from './kzg'\r\n *\r\n * const blobs = toBlobs({ data: '0x1234' })\r\n * const [commitment] = blobsToCommitments({ blobs, kzg })\r\n * const versionedHash = commitmentToVersionedHash({ commitment })\r\n * ```\r\n */\r\nexport function commitmentToVersionedHash<\r\n  const commitment extends Hex | ByteArray,\r\n  to extends To =\r\n    | (commitment extends Hex ? 'hex' : never)\r\n    | (commitment extends ByteArray ? 'bytes' : never),\r\n>(\r\n  parameters: CommitmentToVersionedHashParameters<commitment, to>,\r\n): CommitmentToVersionedHashReturnType<to> {\r\n  const { commitment, version = 1 } = parameters\r\n  const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes')\r\n\r\n  const versionedHash = sha256(commitment, 'bytes')\r\n  versionedHash.set([version], 0)\r\n  return (\r\n    to === 'bytes' ? versionedHash : bytesToHex(versionedHash)\r\n  ) as CommitmentToVersionedHashReturnType<to>\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport {\r\n  type CommitmentToVersionedHashErrorType,\r\n  commitmentToVersionedHash,\r\n} from './commitmentToVersionedHash.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type CommitmentsToVersionedHashesParameters<\r\n  commitments extends readonly Uint8Array[] | readonly Hex[] =\r\n    | readonly Uint8Array[]\r\n    | readonly Hex[],\r\n  to extends To | undefined = undefined,\r\n> = {\r\n  /** Commitments from blobs. */\r\n  commitments: commitments | readonly Uint8Array[] | readonly Hex[]\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n  /** Version to tag onto the hashes. */\r\n  version?: number | undefined\r\n}\r\n\r\nexport type CommitmentsToVersionedHashesReturnType<to extends To> =\r\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\r\n  | (to extends 'hex' ? readonly Hex[] : never)\r\n\r\nexport type CommitmentsToVersionedHashesErrorType =\r\n  | CommitmentToVersionedHashErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Transform a list of commitments to their versioned hashes.\r\n *\r\n * @example\r\n * ```ts\r\n * import {\r\n *   blobsToCommitments,\r\n *   commitmentsToVersionedHashes,\r\n *   toBlobs\r\n * } from 'viem'\r\n * import { kzg } from './kzg'\r\n *\r\n * const blobs = toBlobs({ data: '0x1234' })\r\n * const commitments = blobsToCommitments({ blobs, kzg })\r\n * const versionedHashes = commitmentsToVersionedHashes({ commitments })\r\n * ```\r\n */\r\nexport function commitmentsToVersionedHashes<\r\n  const commitments extends readonly Uint8Array[] | readonly Hex[],\r\n  to extends To =\r\n    | (commitments extends readonly Hex[] ? 'hex' : never)\r\n    | (commitments extends readonly ByteArray[] ? 'bytes' : never),\r\n>(\r\n  parameters: CommitmentsToVersionedHashesParameters<commitments, to>,\r\n): CommitmentsToVersionedHashesReturnType<to> {\r\n  const { commitments, version } = parameters\r\n\r\n  const to =\r\n    parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes')\r\n\r\n  const hashes: Uint8Array[] | Hex[] = []\r\n  for (const commitment of commitments) {\r\n    hashes.push(\r\n      commitmentToVersionedHash({\r\n        commitment,\r\n        to,\r\n        version,\r\n      }) as any,\r\n    )\r\n  }\r\n  return hashes as any\r\n}\r\n", "// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\r\n\r\n/** Blob limit per transaction. */\r\nconst blobsPerTransaction = 6\r\n\r\n/** The number of bytes in a BLS scalar field element. */\r\nexport const bytesPerFieldElement = 32\r\n\r\n/** The number of field elements in a blob. */\r\nexport const fieldElementsPerBlob = 4096\r\n\r\n/** The number of bytes in a blob. */\r\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\r\n\r\n/** Blob bytes limit per transaction. */\r\nexport const maxBytesPerTransaction =\r\n  bytesPerBlob * blobsPerTransaction -\r\n  // terminator byte (0x80).\r\n  1 -\r\n  // zero byte (0x00) appended to each field element.\r\n  1 * fieldElementsPerBlob * blobsPerTransaction\r\n", "// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\r\n\r\nexport const versionedHashVersionKzg = 1\r\n", "import { versionedHashVersionKzg } from '../constants/kzg.js'\r\nimport type { Hash } from '../types/misc.js'\r\n\r\nimport { BaseError } from './base.js'\r\n\r\nexport type BlobSizeTooLargeErrorType = BlobSizeTooLargeError & {\r\n  name: 'BlobSizeTooLargeError'\r\n}\r\nexport class BlobSizeTooLargeError extends BaseError {\r\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\r\n    super('Blob size is too large.', {\r\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\r\n      name: 'BlobSizeTooLargeError',\r\n    })\r\n  }\r\n}\r\n\r\nexport type EmptyBlobErrorType = EmptyBlobError & {\r\n  name: 'EmptyBlobError'\r\n}\r\nexport class EmptyBlobError extends BaseError {\r\n  constructor() {\r\n    super('Blob data must not be empty.', { name: 'EmptyBlobError' })\r\n  }\r\n}\r\n\r\nexport type InvalidVersionedHashSizeErrorType =\r\n  InvalidVersionedHashSizeError & {\r\n    name: 'InvalidVersionedHashSizeError'\r\n  }\r\nexport class InvalidVersionedHashSizeError extends BaseError {\r\n  constructor({\r\n    hash,\r\n    size,\r\n  }: {\r\n    hash: Hash\r\n    size: number\r\n  }) {\r\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\r\n      metaMessages: ['Expected: 32', `Received: ${size}`],\r\n      name: 'InvalidVersionedHashSizeError',\r\n    })\r\n  }\r\n}\r\n\r\nexport type InvalidVersionedHashVersionErrorType =\r\n  InvalidVersionedHashVersionError & {\r\n    name: 'InvalidVersionedHashVersionError'\r\n  }\r\nexport class InvalidVersionedHashVersionError extends BaseError {\r\n  constructor({\r\n    hash,\r\n    version,\r\n  }: {\r\n    hash: Hash\r\n    version: number\r\n  }) {\r\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\r\n      metaMessages: [\r\n        `Expected: ${versionedHashVersionKzg}`,\r\n        `Received: ${version}`,\r\n      ],\r\n      name: 'InvalidVersionedHashVersionError',\r\n    })\r\n  }\r\n}\r\n", "import {\r\n  bytesPerBlob,\r\n  bytesPerFieldElement,\r\n  fieldElementsPerBlob,\r\n  maxBytesPerTransaction,\r\n} from '../../constants/blob.js'\r\nimport {\r\n  BlobSizeTooLargeError,\r\n  type BlobSizeTooLargeErrorType,\r\n  EmptyBlobError,\r\n  type EmptyBlobErrorType,\r\n} from '../../errors/blob.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport { type CreateCursorErrorType, createCursor } from '../cursor.js'\r\nimport { type SizeErrorType, size } from '../data/size.js'\r\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\r\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type ToBlobsParameters<\r\n  data extends Hex | ByteArray = Hex | ByteArray,\r\n  to extends To | undefined = undefined,\r\n> = {\r\n  /** Data to transform to a blob. */\r\n  data: data | Hex | ByteArray\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n}\r\n\r\nexport type ToBlobsReturnType<to extends To> =\r\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\r\n  | (to extends 'hex' ? readonly Hex[] : never)\r\n\r\nexport type ToBlobsErrorType =\r\n  | BlobSizeTooLargeErrorType\r\n  | BytesToHexErrorType\r\n  | CreateCursorErrorType\r\n  | EmptyBlobErrorType\r\n  | HexToBytesErrorType\r\n  | SizeErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Transforms arbitrary data to blobs.\r\n *\r\n * @example\r\n * ```ts\r\n * import { toBlobs, stringToHex } from 'viem'\r\n *\r\n * const blobs = toBlobs({ data: stringToHex('hello world') })\r\n * ```\r\n */\r\nexport function toBlobs<\r\n  const data extends Hex | ByteArray,\r\n  to extends To =\r\n    | (data extends Hex ? 'hex' : never)\r\n    | (data extends ByteArray ? 'bytes' : never),\r\n>(parameters: ToBlobsParameters<data, to>): ToBlobsReturnType<to> {\r\n  const to =\r\n    parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes')\r\n  const data = (\r\n    typeof parameters.data === 'string'\r\n      ? hexToBytes(parameters.data)\r\n      : parameters.data\r\n  ) as ByteArray\r\n\r\n  const size_ = size(data)\r\n  if (!size_) throw new EmptyBlobError()\r\n  if (size_ > maxBytesPerTransaction)\r\n    throw new BlobSizeTooLargeError({\r\n      maxSize: maxBytesPerTransaction,\r\n      size: size_,\r\n    })\r\n\r\n  const blobs = []\r\n\r\n  let active = true\r\n  let position = 0\r\n  while (active) {\r\n    const blob = createCursor(new Uint8Array(bytesPerBlob))\r\n\r\n    let size = 0\r\n    while (size < fieldElementsPerBlob) {\r\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1))\r\n\r\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\r\n      blob.pushByte(0x00)\r\n\r\n      // Push the current segment of data bytes.\r\n      blob.pushBytes(bytes)\r\n\r\n      // If we detect that the current segment of data bytes is less than 31 bytes,\r\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\r\n      if (bytes.length < 31) {\r\n        blob.pushByte(0x80)\r\n        active = false\r\n        break\r\n      }\r\n\r\n      size++\r\n      position += 31\r\n    }\r\n\r\n    blobs.push(blob)\r\n  }\r\n\r\n  return (\r\n    to === 'bytes'\r\n      ? blobs.map((x) => x.bytes)\r\n      : blobs.map((x) => bytesToHex(x.bytes))\r\n  ) as any\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { BlobSidecars } from '../../types/eip4844.js'\r\nimport type { Kzg } from '../../types/kzg.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport type { OneOf } from '../../types/utils.js'\r\nimport {\r\n  type BlobsToCommitmentsErrorType,\r\n  blobsToCommitments,\r\n} from './blobsToCommitments.js'\r\nimport { blobsToProofs, type blobsToProofsErrorType } from './blobsToProofs.js'\r\nimport { type ToBlobsErrorType, toBlobs } from './toBlobs.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type ToBlobSidecarsParameters<\r\n  data extends Hex | ByteArray | undefined = undefined,\r\n  blobs extends readonly Hex[] | readonly ByteArray[] | undefined = undefined,\r\n  to extends To =\r\n    | (blobs extends readonly Hex[] ? 'hex' : never)\r\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\r\n  ///\r\n  _blobsType =\r\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\r\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\r\n> = {\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n} & OneOf<\r\n  | {\r\n      /** Data to transform into blobs. */\r\n      data: data | Hex | ByteArray\r\n      /** KZG implementation. */\r\n      kzg: Kzg\r\n    }\r\n  | {\r\n      /** Blobs. */\r\n      blobs: blobs | readonly Hex[] | readonly ByteArray[]\r\n      /** Commitment for each blob. */\r\n      commitments: _blobsType | readonly Hex[] | readonly ByteArray[]\r\n      /** Proof for each blob. */\r\n      proofs: _blobsType | readonly Hex[] | readonly ByteArray[]\r\n    }\r\n>\r\n\r\nexport type ToBlobSidecarsReturnType<to extends To> =\r\n  | (to extends 'bytes' ? BlobSidecars<ByteArray> : never)\r\n  | (to extends 'hex' ? BlobSidecars<Hex> : never)\r\n\r\nexport type ToBlobSidecarsErrorType =\r\n  | BlobsToCommitmentsErrorType\r\n  | ToBlobsErrorType\r\n  | blobsToProofsErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.\r\n *\r\n * @example\r\n * ```ts\r\n * import { toBlobSidecars, stringToHex } from 'viem'\r\n *\r\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\r\n * ```\r\n *\r\n * @example\r\n * ```ts\r\n * import {\r\n *   blobsToCommitments,\r\n *   toBlobs,\r\n *   blobsToProofs,\r\n *   toBlobSidecars,\r\n *   stringToHex\r\n * } from 'viem'\r\n *\r\n * const blobs = toBlobs({ data: stringToHex('hello world') })\r\n * const commitments = blobsToCommitments({ blobs, kzg })\r\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\r\n *\r\n * const sidecars = toBlobSidecars({ blobs, commitments, proofs })\r\n * ```\r\n */\r\nexport function toBlobSidecars<\r\n  const data extends Hex | ByteArray | undefined = undefined,\r\n  const blobs extends\r\n    | readonly Hex[]\r\n    | readonly ByteArray[]\r\n    | undefined = undefined,\r\n  to extends To =\r\n    | (data extends Hex ? 'hex' : never)\r\n    | (data extends ByteArray ? 'bytes' : never)\r\n    | (blobs extends readonly Hex[] ? 'hex' : never)\r\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\r\n>(\r\n  parameters: ToBlobSidecarsParameters<data, blobs, to>,\r\n): ToBlobSidecarsReturnType<to> {\r\n  const { data, kzg, to } = parameters\r\n  const blobs = parameters.blobs ?? toBlobs({ data: data!, to })\r\n  const commitments =\r\n    parameters.commitments ?? blobsToCommitments({ blobs, kzg: kzg!, to })\r\n  const proofs =\r\n    parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg: kzg!, to })\r\n\r\n  const sidecars: BlobSidecars = []\r\n  for (let i = 0; i < blobs.length; i++)\r\n    sidecars.push({\r\n      blob: blobs[i],\r\n      commitment: commitments[i],\r\n      proof: proofs[i],\r\n    })\r\n\r\n  return sidecars as ToBlobSidecarsReturnType<to>\r\n}\r\n", "import { versionedHashVersionKzg } from '../../constants/kzg.js'\r\nimport { maxUint256 } from '../../constants/number.js'\r\nimport {\r\n  InvalidAddressError,\r\n  type InvalidAddressErrorType,\r\n} from '../../errors/address.js'\r\nimport { BaseError, type BaseErrorType } from '../../errors/base.js'\r\nimport {\r\n  EmptyBlobError,\r\n  type EmptyBlobErrorType,\r\n  InvalidVersionedHashSizeError,\r\n  type InvalidVersionedHashSizeErrorType,\r\n  InvalidVersionedHashVersionError,\r\n  type InvalidVersionedHashVersionErrorType,\r\n} from '../../errors/blob.js'\r\nimport {\r\n  InvalidChainIdError,\r\n  type InvalidChainIdErrorType,\r\n} from '../../errors/chain.js'\r\nimport {\r\n  FeeCapTooHighError,\r\n  type FeeCapTooHighErrorType,\r\n  TipAboveFeeCapError,\r\n  type TipAboveFeeCapErrorType,\r\n} from '../../errors/node.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type {\r\n  TransactionSerializableEIP1559,\r\n  TransactionSerializableEIP2930,\r\n  TransactionSerializableEIP4844,\r\n  TransactionSerializableEIP7702,\r\n  TransactionSerializableLegacy,\r\n} from '../../types/transaction.js'\r\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\r\nimport { size } from '../data/size.js'\r\nimport { slice } from '../data/slice.js'\r\nimport { hexToNumber } from '../encoding/fromHex.js'\r\n\r\nexport type AssertTransactionEIP7702ErrorType =\r\n  | AssertTransactionEIP1559ErrorType\r\n  | InvalidAddressErrorType\r\n  | InvalidChainIdErrorType\r\n  | ErrorType\r\n\r\nexport function assertTransactionEIP7702(\r\n  transaction: TransactionSerializableEIP7702,\r\n) {\r\n  const { authorizationList } = transaction\r\n  if (authorizationList) {\r\n    for (const authorization of authorizationList) {\r\n      const { chainId } = authorization\r\n      const address = authorization.address\r\n      if (!isAddress(address)) throw new InvalidAddressError({ address })\r\n      if (chainId < 0) throw new InvalidChainIdError({ chainId })\r\n    }\r\n  }\r\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\r\n}\r\n\r\nexport type AssertTransactionEIP4844ErrorType =\r\n  | AssertTransactionEIP1559ErrorType\r\n  | EmptyBlobErrorType\r\n  | InvalidVersionedHashSizeErrorType\r\n  | InvalidVersionedHashVersionErrorType\r\n  | ErrorType\r\n\r\nexport function assertTransactionEIP4844(\r\n  transaction: TransactionSerializableEIP4844,\r\n) {\r\n  const { blobVersionedHashes } = transaction\r\n  if (blobVersionedHashes) {\r\n    if (blobVersionedHashes.length === 0) throw new EmptyBlobError()\r\n    for (const hash of blobVersionedHashes) {\r\n      const size_ = size(hash)\r\n      const version = hexToNumber(slice(hash, 0, 1))\r\n      if (size_ !== 32)\r\n        throw new InvalidVersionedHashSizeError({ hash, size: size_ })\r\n      if (version !== versionedHashVersionKzg)\r\n        throw new InvalidVersionedHashVersionError({\r\n          hash,\r\n          version,\r\n        })\r\n    }\r\n  }\r\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\r\n}\r\n\r\nexport type AssertTransactionEIP1559ErrorType =\r\n  | BaseErrorType\r\n  | IsAddressErrorType\r\n  | InvalidAddressErrorType\r\n  | InvalidChainIdErrorType\r\n  | FeeCapTooHighErrorType\r\n  | TipAboveFeeCapErrorType\r\n  | ErrorType\r\n\r\nexport function assertTransactionEIP1559(\r\n  transaction: TransactionSerializableEIP1559,\r\n) {\r\n  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction\r\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\r\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\r\n  if (maxFeePerGas && maxFeePerGas > maxUint256)\r\n    throw new FeeCapTooHighError({ maxFeePerGas })\r\n  if (\r\n    maxPriorityFeePerGas &&\r\n    maxFeePerGas &&\r\n    maxPriorityFeePerGas > maxFeePerGas\r\n  )\r\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\r\n}\r\n\r\nexport type AssertTransactionEIP2930ErrorType =\r\n  | BaseErrorType\r\n  | IsAddressErrorType\r\n  | InvalidAddressErrorType\r\n  | InvalidChainIdErrorType\r\n  | FeeCapTooHighErrorType\r\n  | ErrorType\r\n\r\nexport function assertTransactionEIP2930(\r\n  transaction: TransactionSerializableEIP2930,\r\n) {\r\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\r\n    transaction\r\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\r\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\r\n  if (maxPriorityFeePerGas || maxFeePerGas)\r\n    throw new BaseError(\r\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.',\r\n    )\r\n  if (gasPrice && gasPrice > maxUint256)\r\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\r\n}\r\n\r\nexport type AssertTransactionLegacyErrorType =\r\n  | BaseErrorType\r\n  | IsAddressErrorType\r\n  | InvalidAddressErrorType\r\n  | InvalidChainIdErrorType\r\n  | FeeCapTooHighErrorType\r\n  | ErrorType\r\n\r\nexport function assertTransactionLegacy(\r\n  transaction: TransactionSerializableLegacy,\r\n) {\r\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\r\n    transaction\r\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\r\n  if (typeof chainId !== 'undefined' && chainId <= 0)\r\n    throw new InvalidChainIdError({ chainId })\r\n  if (maxPriorityFeePerGas || maxFeePerGas)\r\n    throw new BaseError(\r\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.',\r\n    )\r\n  if (gasPrice && gasPrice > maxUint256)\r\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\r\n}\r\n", "import {\r\n  InvalidSerializableTransactionError,\r\n  type InvalidSerializableTransactionErrorType,\r\n} from '../../errors/transaction.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type {\r\n  FeeValuesEIP1559,\r\n  FeeValuesEIP4844,\r\n  FeeValuesLegacy,\r\n} from '../../index.js'\r\nimport type {\r\n  TransactionRequestGeneric,\r\n  TransactionSerializableEIP2930,\r\n  TransactionSerializableEIP4844,\r\n  TransactionSerializableEIP7702,\r\n  TransactionSerializableGeneric,\r\n} from '../../types/transaction.js'\r\nimport type { Assign, ExactPartial, IsNever, OneOf } from '../../types/utils.js'\r\n\r\nexport type GetTransactionType<\r\n  transaction extends OneOf<\r\n    TransactionSerializableGeneric | TransactionRequestGeneric\r\n  > = TransactionSerializableGeneric,\r\n  result =\r\n    | (transaction extends LegacyProperties ? 'legacy' : never)\r\n    | (transaction extends EIP1559Properties ? 'eip1559' : never)\r\n    | (transaction extends EIP2930Properties ? 'eip2930' : never)\r\n    | (transaction extends EIP4844Properties ? 'eip4844' : never)\r\n    | (transaction extends EIP7702Properties ? 'eip7702' : never)\r\n    | (transaction['type'] extends TransactionSerializableGeneric['type']\r\n        ? Extract<transaction['type'], string>\r\n        : never),\r\n> = IsNever<keyof transaction> extends true\r\n  ? string\r\n  : IsNever<result> extends false\r\n    ? result\r\n    : string\r\n\r\nexport type GetTransactionTypeErrorType =\r\n  | InvalidSerializableTransactionErrorType\r\n  | ErrorType\r\n\r\nexport function getTransactionType<\r\n  const transaction extends OneOf<\r\n    TransactionSerializableGeneric | TransactionRequestGeneric\r\n  >,\r\n>(transaction: transaction): GetTransactionType<transaction> {\r\n  if (transaction.type)\r\n    return transaction.type as GetTransactionType<transaction>\r\n\r\n  if (typeof transaction.authorizationList !== 'undefined')\r\n    return 'eip7702' as any\r\n\r\n  if (\r\n    typeof transaction.blobs !== 'undefined' ||\r\n    typeof transaction.blobVersionedHashes !== 'undefined' ||\r\n    typeof transaction.maxFeePerBlobGas !== 'undefined' ||\r\n    typeof transaction.sidecars !== 'undefined'\r\n  )\r\n    return 'eip4844' as any\r\n\r\n  if (\r\n    typeof transaction.maxFeePerGas !== 'undefined' ||\r\n    typeof transaction.maxPriorityFeePerGas !== 'undefined'\r\n  ) {\r\n    return 'eip1559' as any\r\n  }\r\n\r\n  if (typeof transaction.gasPrice !== 'undefined') {\r\n    if (typeof transaction.accessList !== 'undefined') return 'eip2930' as any\r\n    return 'legacy' as any\r\n  }\r\n\r\n  throw new InvalidSerializableTransactionError({ transaction })\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n// Types\r\n\r\ntype BaseProperties = {\r\n  accessList?: undefined\r\n  authorizationList?: undefined\r\n  blobs?: undefined\r\n  blobVersionedHashes?: undefined\r\n  gasPrice?: undefined\r\n  maxFeePerBlobGas?: undefined\r\n  maxFeePerGas?: undefined\r\n  maxPriorityFeePerGas?: undefined\r\n  sidecars?: undefined\r\n}\r\n\r\ntype LegacyProperties = Assign<BaseProperties, FeeValuesLegacy>\r\ntype EIP1559Properties = Assign<\r\n  BaseProperties,\r\n  OneOf<\r\n    | {\r\n        maxFeePerGas: FeeValuesEIP1559['maxFeePerGas']\r\n      }\r\n    | {\r\n        maxPriorityFeePerGas: FeeValuesEIP1559['maxPriorityFeePerGas']\r\n      },\r\n    FeeValuesEIP1559\r\n  > & {\r\n    accessList?: TransactionSerializableEIP2930['accessList'] | undefined\r\n  }\r\n>\r\ntype EIP2930Properties = Assign<\r\n  ExactPartial<LegacyProperties>,\r\n  {\r\n    accessList: TransactionSerializableEIP2930['accessList']\r\n  }\r\n>\r\ntype EIP4844Properties = Assign<\r\n  ExactPartial<EIP1559Properties>,\r\n  ExactPartial<FeeValuesEIP4844> &\r\n    OneOf<\r\n      | {\r\n          blobs: TransactionSerializableEIP4844['blobs']\r\n        }\r\n      | {\r\n          blobVersionedHashes: TransactionSerializableEIP4844['blobVersionedHashes']\r\n        }\r\n      | {\r\n          sidecars: TransactionSerializableEIP4844['sidecars']\r\n        },\r\n      TransactionSerializableEIP4844\r\n    >\r\n>\r\ntype EIP7702Properties = Assign<\r\n  ExactPartial<EIP1559Properties>,\r\n  {\r\n    authorizationList: TransactionSerializableEIP7702['authorizationList']\r\n  }\r\n>\r\n", "import {\r\n  InvalidAddressError,\r\n  type InvalidAddressErrorType,\r\n} from '../../errors/address.js'\r\nimport {\r\n  InvalidStorageKeySizeError,\r\n  type InvalidStorageKeySizeErrorType,\r\n} from '../../errors/transaction.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { Hex } from '../../types/misc.js'\r\nimport type { AccessList } from '../../types/transaction.js'\r\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\r\nimport type { RecursiveArray } from '../encoding/toRlp.js'\r\n\r\nexport type SerializeAccessListErrorType =\r\n  | InvalidStorageKeySizeErrorType\r\n  | InvalidAddressErrorType\r\n  | IsAddressErrorType\r\n  | ErrorType\r\n\r\n/*\r\n * Serialize an  EIP-2930 access list\r\n * @remarks\r\n * Use to create a transaction serializer with support for EIP-2930 access lists\r\n *\r\n * @param accessList - Array of objects of address and arrays of Storage Keys\r\n * @throws InvalidAddressError, InvalidStorageKeySizeError\r\n * @returns Array of hex strings\r\n */\r\nexport function serializeAccessList(\r\n  accessList?: AccessList | undefined,\r\n): RecursiveArray<Hex> {\r\n  if (!accessList || accessList.length === 0) return []\r\n\r\n  const serializedAccessList = []\r\n  for (let i = 0; i < accessList.length; i++) {\r\n    const { address, storageKeys } = accessList[i]\r\n\r\n    for (let j = 0; j < storageKeys.length; j++) {\r\n      if (storageKeys[j].length - 2 !== 64) {\r\n        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] })\r\n      }\r\n    }\r\n\r\n    if (!isAddress(address, { strict: false })) {\r\n      throw new InvalidAddressError({ address })\r\n    }\r\n\r\n    serializedAccessList.push([address, storageKeys])\r\n  }\r\n  return serializedAccessList\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type {\r\n  AuthorizationList,\r\n  SerializedAuthorizationList,\r\n} from '../../types/authorization.js'\r\nimport { toHex } from '../encoding/toHex.js'\r\nimport { toYParitySignatureArray } from '../transaction/serializeTransaction.js'\r\n\r\nexport type SerializeAuthorizationListReturnType = SerializedAuthorizationList\r\n\r\nexport type SerializeAuthorizationListErrorType = ErrorType\r\n\r\n/*\r\n * Serializes an EIP-7702 authorization list.\r\n */\r\nexport function serializeAuthorizationList(\r\n  authorizationList?: AuthorizationList<number, true> | undefined,\r\n): SerializeAuthorizationListReturnType {\r\n  if (!authorizationList || authorizationList.length === 0) return []\r\n\r\n  const serializedAuthorizationList = []\r\n  for (const authorization of authorizationList) {\r\n    const { chainId, nonce, ...signature } = authorization\r\n    const contractAddress = authorization.address\r\n    serializedAuthorizationList.push([\r\n      chainId ? toHex(chainId) : '0x',\r\n      contractAddress,\r\n      nonce ? toHex(nonce) : '0x',\r\n      ...toYParitySignatureArray({}, signature),\r\n    ])\r\n  }\r\n\r\n  return serializedAuthorizationList as {} as SerializeAuthorizationListReturnType\r\n}\r\n", "import {\r\n  InvalidLegacyVError,\r\n  type InvalidLegacyVErrorType,\r\n} from '../../errors/transaction.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type {\r\n  ByteArray,\r\n  Hex,\r\n  Signature,\r\n  SignatureLegacy,\r\n} from '../../types/misc.js'\r\nimport type {\r\n  TransactionSerializable,\r\n  TransactionSerializableEIP1559,\r\n  TransactionSerializableEIP2930,\r\n  TransactionSerializableEIP4844,\r\n  TransactionSerializableEIP7702,\r\n  TransactionSerializableGeneric,\r\n  TransactionSerializableLegacy,\r\n  TransactionSerialized,\r\n  TransactionSerializedEIP1559,\r\n  TransactionSerializedEIP2930,\r\n  TransactionSerializedEIP4844,\r\n  TransactionSerializedEIP7702,\r\n  TransactionSerializedLegacy,\r\n  TransactionType,\r\n} from '../../types/transaction.js'\r\nimport type { OneOf } from '../../types/utils.js'\r\nimport {\r\n  type SerializeAuthorizationListErrorType,\r\n  serializeAuthorizationList,\r\n} from '../authorization/serializeAuthorizationList.js'\r\nimport {\r\n  type BlobsToCommitmentsErrorType,\r\n  blobsToCommitments,\r\n} from '../blob/blobsToCommitments.js'\r\nimport {\r\n  blobsToProofs,\r\n  type blobsToProofsErrorType,\r\n} from '../blob/blobsToProofs.js'\r\nimport {\r\n  type CommitmentsToVersionedHashesErrorType,\r\n  commitmentsToVersionedHashes,\r\n} from '../blob/commitmentsToVersionedHashes.js'\r\nimport {\r\n  type ToBlobSidecarsErrorType,\r\n  toBlobSidecars,\r\n} from '../blob/toBlobSidecars.js'\r\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\r\nimport { trim } from '../data/trim.js'\r\nimport { type ToHexErrorType, bytesToHex, toHex } from '../encoding/toHex.js'\r\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\r\n\r\nimport {\r\n  type AssertTransactionEIP1559ErrorType,\r\n  type AssertTransactionEIP2930ErrorType,\r\n  type AssertTransactionEIP4844ErrorType,\r\n  type AssertTransactionEIP7702ErrorType,\r\n  type AssertTransactionLegacyErrorType,\r\n  assertTransactionEIP1559,\r\n  assertTransactionEIP2930,\r\n  assertTransactionEIP4844,\r\n  assertTransactionEIP7702,\r\n  assertTransactionLegacy,\r\n} from './assertTransaction.js'\r\nimport {\r\n  type GetTransactionType,\r\n  type GetTransactionTypeErrorType,\r\n  getTransactionType,\r\n} from './getTransactionType.js'\r\nimport {\r\n  type SerializeAccessListErrorType,\r\n  serializeAccessList,\r\n} from './serializeAccessList.js'\r\n\r\nexport type SerializedTransactionReturnType<\r\n  transaction extends TransactionSerializable = TransactionSerializable,\r\n  ///\r\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\r\n> = TransactionSerialized<_transactionType>\r\n\r\nexport type SerializeTransactionFn<\r\n  transaction extends TransactionSerializableGeneric = TransactionSerializable,\r\n  ///\r\n  _transactionType extends TransactionType = never,\r\n> = typeof serializeTransaction<\r\n  OneOf<TransactionSerializable | transaction>,\r\n  _transactionType\r\n>\r\n\r\nexport type SerializeTransactionErrorType =\r\n  | GetTransactionTypeErrorType\r\n  | SerializeTransactionEIP1559ErrorType\r\n  | SerializeTransactionEIP2930ErrorType\r\n  | SerializeTransactionEIP4844ErrorType\r\n  | SerializeTransactionEIP7702ErrorType\r\n  | SerializeTransactionLegacyErrorType\r\n  | ErrorType\r\n\r\nexport function serializeTransaction<\r\n  const transaction extends TransactionSerializable,\r\n  ///\r\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\r\n>(\r\n  transaction: transaction,\r\n  signature?: Signature | undefined,\r\n): SerializedTransactionReturnType<transaction, _transactionType> {\r\n  const type = getTransactionType(transaction) as GetTransactionType\r\n\r\n  if (type === 'eip1559')\r\n    return serializeTransactionEIP1559(\r\n      transaction as TransactionSerializableEIP1559,\r\n      signature,\r\n    ) as SerializedTransactionReturnType<transaction>\r\n\r\n  if (type === 'eip2930')\r\n    return serializeTransactionEIP2930(\r\n      transaction as TransactionSerializableEIP2930,\r\n      signature,\r\n    ) as SerializedTransactionReturnType<transaction>\r\n\r\n  if (type === 'eip4844')\r\n    return serializeTransactionEIP4844(\r\n      transaction as TransactionSerializableEIP4844,\r\n      signature,\r\n    ) as SerializedTransactionReturnType<transaction>\r\n\r\n  if (type === 'eip7702')\r\n    return serializeTransactionEIP7702(\r\n      transaction as TransactionSerializableEIP7702,\r\n      signature,\r\n    ) as SerializedTransactionReturnType<transaction>\r\n\r\n  return serializeTransactionLegacy(\r\n    transaction as TransactionSerializableLegacy,\r\n    signature as SignatureLegacy,\r\n  ) as SerializedTransactionReturnType<transaction>\r\n}\r\n\r\ntype SerializeTransactionEIP7702ErrorType =\r\n  | AssertTransactionEIP7702ErrorType\r\n  | SerializeAuthorizationListErrorType\r\n  | ConcatHexErrorType\r\n  | InvalidLegacyVErrorType\r\n  | ToHexErrorType\r\n  | ToRlpErrorType\r\n  | SerializeAccessListErrorType\r\n  | ErrorType\r\n\r\nfunction serializeTransactionEIP7702(\r\n  transaction: TransactionSerializableEIP7702,\r\n  signature?: Signature | undefined,\r\n): TransactionSerializedEIP7702 {\r\n  const {\r\n    authorizationList,\r\n    chainId,\r\n    gas,\r\n    nonce,\r\n    to,\r\n    value,\r\n    maxFeePerGas,\r\n    maxPriorityFeePerGas,\r\n    accessList,\r\n    data,\r\n  } = transaction\r\n\r\n  assertTransactionEIP7702(transaction)\r\n\r\n  const serializedAccessList = serializeAccessList(accessList)\r\n  const serializedAuthorizationList =\r\n    serializeAuthorizationList(authorizationList)\r\n\r\n  return concatHex([\r\n    '0x04',\r\n    toRlp([\r\n      toHex(chainId),\r\n      nonce ? toHex(nonce) : '0x',\r\n      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\r\n      maxFeePerGas ? toHex(maxFeePerGas) : '0x',\r\n      gas ? toHex(gas) : '0x',\r\n      to ?? '0x',\r\n      value ? toHex(value) : '0x',\r\n      data ?? '0x',\r\n      serializedAccessList,\r\n      serializedAuthorizationList,\r\n      ...toYParitySignatureArray(transaction, signature),\r\n    ]),\r\n  ]) as TransactionSerializedEIP7702\r\n}\r\n\r\ntype SerializeTransactionEIP4844ErrorType =\r\n  | AssertTransactionEIP4844ErrorType\r\n  | BlobsToCommitmentsErrorType\r\n  | CommitmentsToVersionedHashesErrorType\r\n  | blobsToProofsErrorType\r\n  | ToBlobSidecarsErrorType\r\n  | ConcatHexErrorType\r\n  | InvalidLegacyVErrorType\r\n  | ToHexErrorType\r\n  | ToRlpErrorType\r\n  | SerializeAccessListErrorType\r\n  | ErrorType\r\n\r\nfunction serializeTransactionEIP4844(\r\n  transaction: TransactionSerializableEIP4844,\r\n  signature?: Signature | undefined,\r\n): TransactionSerializedEIP4844 {\r\n  const {\r\n    chainId,\r\n    gas,\r\n    nonce,\r\n    to,\r\n    value,\r\n    maxFeePerBlobGas,\r\n    maxFeePerGas,\r\n    maxPriorityFeePerGas,\r\n    accessList,\r\n    data,\r\n  } = transaction\r\n\r\n  assertTransactionEIP4844(transaction)\r\n\r\n  let blobVersionedHashes = transaction.blobVersionedHashes\r\n  let sidecars = transaction.sidecars\r\n  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.\r\n  if (\r\n    transaction.blobs &&\r\n    (typeof blobVersionedHashes === 'undefined' ||\r\n      typeof sidecars === 'undefined')\r\n  ) {\r\n    const blobs = (\r\n      typeof transaction.blobs[0] === 'string'\r\n        ? transaction.blobs\r\n        : (transaction.blobs as ByteArray[]).map((x) => bytesToHex(x))\r\n    ) as Hex[]\r\n    const kzg = transaction.kzg!\r\n    const commitments = blobsToCommitments({\r\n      blobs,\r\n      kzg,\r\n    })\r\n\r\n    if (typeof blobVersionedHashes === 'undefined')\r\n      blobVersionedHashes = commitmentsToVersionedHashes({\r\n        commitments,\r\n      })\r\n    if (typeof sidecars === 'undefined') {\r\n      const proofs = blobsToProofs({ blobs, commitments, kzg })\r\n      sidecars = toBlobSidecars({ blobs, commitments, proofs })\r\n    }\r\n  }\r\n\r\n  const serializedAccessList = serializeAccessList(accessList)\r\n\r\n  const serializedTransaction = [\r\n    toHex(chainId),\r\n    nonce ? toHex(nonce) : '0x',\r\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\r\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\r\n    gas ? toHex(gas) : '0x',\r\n    to ?? '0x',\r\n    value ? toHex(value) : '0x',\r\n    data ?? '0x',\r\n    serializedAccessList,\r\n    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x',\r\n    blobVersionedHashes ?? [],\r\n    ...toYParitySignatureArray(transaction, signature),\r\n  ] as const\r\n\r\n  const blobs: Hex[] = []\r\n  const commitments: Hex[] = []\r\n  const proofs: Hex[] = []\r\n  if (sidecars)\r\n    for (let i = 0; i < sidecars.length; i++) {\r\n      const { blob, commitment, proof } = sidecars[i]\r\n      blobs.push(blob)\r\n      commitments.push(commitment)\r\n      proofs.push(proof)\r\n    }\r\n\r\n  return concatHex([\r\n    '0x03',\r\n    sidecars\r\n      ? // If sidecars are enabled, envelope turns into a \"wrapper\":\r\n        toRlp([serializedTransaction, blobs, commitments, proofs])\r\n      : // If sidecars are disabled, standard envelope is used:\r\n        toRlp(serializedTransaction),\r\n  ]) as TransactionSerializedEIP4844\r\n}\r\n\r\ntype SerializeTransactionEIP1559ErrorType =\r\n  | AssertTransactionEIP1559ErrorType\r\n  | ConcatHexErrorType\r\n  | InvalidLegacyVErrorType\r\n  | ToHexErrorType\r\n  | ToRlpErrorType\r\n  | SerializeAccessListErrorType\r\n  | ErrorType\r\n\r\nfunction serializeTransactionEIP1559(\r\n  transaction: TransactionSerializableEIP1559,\r\n  signature?: Signature | undefined,\r\n): TransactionSerializedEIP1559 {\r\n  const {\r\n    chainId,\r\n    gas,\r\n    nonce,\r\n    to,\r\n    value,\r\n    maxFeePerGas,\r\n    maxPriorityFeePerGas,\r\n    accessList,\r\n    data,\r\n  } = transaction\r\n\r\n  assertTransactionEIP1559(transaction)\r\n\r\n  const serializedAccessList = serializeAccessList(accessList)\r\n\r\n  const serializedTransaction = [\r\n    toHex(chainId),\r\n    nonce ? toHex(nonce) : '0x',\r\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\r\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\r\n    gas ? toHex(gas) : '0x',\r\n    to ?? '0x',\r\n    value ? toHex(value) : '0x',\r\n    data ?? '0x',\r\n    serializedAccessList,\r\n    ...toYParitySignatureArray(transaction, signature),\r\n  ]\r\n\r\n  return concatHex([\r\n    '0x02',\r\n    toRlp(serializedTransaction),\r\n  ]) as TransactionSerializedEIP1559\r\n}\r\n\r\ntype SerializeTransactionEIP2930ErrorType =\r\n  | AssertTransactionEIP2930ErrorType\r\n  | ConcatHexErrorType\r\n  | InvalidLegacyVErrorType\r\n  | ToHexErrorType\r\n  | ToRlpErrorType\r\n  | SerializeAccessListErrorType\r\n  | ErrorType\r\n\r\nfunction serializeTransactionEIP2930(\r\n  transaction: TransactionSerializableEIP2930,\r\n  signature?: Signature | undefined,\r\n): TransactionSerializedEIP2930 {\r\n  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } =\r\n    transaction\r\n\r\n  assertTransactionEIP2930(transaction)\r\n\r\n  const serializedAccessList = serializeAccessList(accessList)\r\n\r\n  const serializedTransaction = [\r\n    toHex(chainId),\r\n    nonce ? toHex(nonce) : '0x',\r\n    gasPrice ? toHex(gasPrice) : '0x',\r\n    gas ? toHex(gas) : '0x',\r\n    to ?? '0x',\r\n    value ? toHex(value) : '0x',\r\n    data ?? '0x',\r\n    serializedAccessList,\r\n    ...toYParitySignatureArray(transaction, signature),\r\n  ]\r\n\r\n  return concatHex([\r\n    '0x01',\r\n    toRlp(serializedTransaction),\r\n  ]) as TransactionSerializedEIP2930\r\n}\r\n\r\ntype SerializeTransactionLegacyErrorType =\r\n  | AssertTransactionLegacyErrorType\r\n  | InvalidLegacyVErrorType\r\n  | ToHexErrorType\r\n  | ToRlpErrorType\r\n  | ErrorType\r\n\r\nfunction serializeTransactionLegacy(\r\n  transaction: TransactionSerializableLegacy,\r\n  signature?: SignatureLegacy | undefined,\r\n): TransactionSerializedLegacy {\r\n  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction\r\n\r\n  assertTransactionLegacy(transaction)\r\n\r\n  let serializedTransaction = [\r\n    nonce ? toHex(nonce) : '0x',\r\n    gasPrice ? toHex(gasPrice) : '0x',\r\n    gas ? toHex(gas) : '0x',\r\n    to ?? '0x',\r\n    value ? toHex(value) : '0x',\r\n    data ?? '0x',\r\n  ]\r\n\r\n  if (signature) {\r\n    const v = (() => {\r\n      // EIP-155 (inferred chainId)\r\n      if (signature.v >= 35n) {\r\n        const inferredChainId = (signature.v - 35n) / 2n\r\n        if (inferredChainId > 0) return signature.v\r\n        return 27n + (signature.v === 35n ? 0n : 1n)\r\n      }\r\n\r\n      // EIP-155 (explicit chainId)\r\n      if (chainId > 0)\r\n        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n)\r\n\r\n      // Pre-EIP-155 (no chainId)\r\n      const v = 27n + (signature.v === 27n ? 0n : 1n)\r\n      if (signature.v !== v) throw new InvalidLegacyVError({ v: signature.v })\r\n      return v\r\n    })()\r\n\r\n    const r = trim(signature.r)\r\n    const s = trim(signature.s)\r\n\r\n    serializedTransaction = [\r\n      ...serializedTransaction,\r\n      toHex(v),\r\n      r === '0x00' ? '0x' : r,\r\n      s === '0x00' ? '0x' : s,\r\n    ]\r\n  } else if (chainId > 0) {\r\n    serializedTransaction = [\r\n      ...serializedTransaction,\r\n      toHex(chainId),\r\n      '0x',\r\n      '0x',\r\n    ]\r\n  }\r\n\r\n  return toRlp(serializedTransaction) as TransactionSerializedLegacy\r\n}\r\n\r\nexport function toYParitySignatureArray(\r\n  transaction: TransactionSerializableGeneric,\r\n  signature_?: Signature | undefined,\r\n) {\r\n  const signature = signature_ ?? transaction\r\n  const { v, yParity } = signature\r\n\r\n  if (typeof signature.r === 'undefined') return []\r\n  if (typeof signature.s === 'undefined') return []\r\n  if (typeof v === 'undefined' && typeof yParity === 'undefined') return []\r\n\r\n  const r = trim(signature.r)\r\n  const s = trim(signature.s)\r\n\r\n  const yParity_ = (() => {\r\n    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x'\r\n    if (v === 0n) return '0x'\r\n    if (v === 1n) return toHex(1)\r\n\r\n    return v === 27n ? '0x' : toHex(1)\r\n  })()\r\n\r\n  return [yParity_, r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s]\r\n}\r\n", "import {\r\n  ChainMismatchError,\r\n  type ChainMismatchErrorType,\r\n  ChainNotFoundError,\r\n  type ChainNotFoundErrorType,\r\n} from '../../errors/chain.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { Chain } from '../../types/chain.js'\r\n\r\nexport type AssertCurrentChainParameters = {\r\n  chain?: Chain | undefined\r\n  currentChainId: number\r\n}\r\n\r\nexport type AssertCurrentChainErrorType =\r\n  | ChainNotFoundErrorType\r\n  | ChainMismatchErrorType\r\n  | ErrorType\r\n\r\nexport function assertCurrentChain({\r\n  chain,\r\n  currentChainId,\r\n}: AssertCurrentChainParameters): void {\r\n  if (!chain) throw new ChainNotFoundError()\r\n  if (currentChainId !== chain.id)\r\n    throw new ChainMismatchError({ chain, currentChainId })\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { Chain } from '../../types/chain.js'\r\n\r\nexport type ExtractChainParameters<\r\n  chains extends readonly Chain[],\r\n  chainId extends chains[number]['id'],\r\n> = {\r\n  chains: chains\r\n  id: chainId | chains[number]['id']\r\n}\r\n\r\nexport type ExtractChainReturnType<\r\n  chains extends readonly Chain[],\r\n  chainId extends chains[number]['id'],\r\n> = Extract<chains[number], { id: chainId }>\r\n\r\nexport type ExtractChainErrorType = ErrorType\r\n\r\nexport function extractChain<\r\n  const chains extends readonly Chain[],\r\n  chainId extends chains[number]['id'],\r\n>({\r\n  chains,\r\n  id,\r\n}: ExtractChainParameters<chains, chainId>): ExtractChainReturnType<\r\n  chains,\r\n  chainId\r\n> {\r\n  return chains.find((chain) => chain.id === id) as ExtractChainReturnType<\r\n    chains,\r\n    chainId\r\n  >\r\n}\r\n", "import { BaseError } from './base.js'\r\n\r\nexport type AccountNotFoundErrorType = AccountNotFoundError & {\r\n  name: 'AccountNotFoundError'\r\n}\r\nexport class AccountNotFoundError extends BaseError {\r\n  constructor({ docsPath }: { docsPath?: string | undefined } = {}) {\r\n    super(\r\n      [\r\n        'Could not find an Account to execute with this Action.',\r\n        'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.',\r\n      ].join('\\n'),\r\n      {\r\n        docsPath,\r\n        docsSlug: 'account',\r\n        name: 'AccountNotFoundError',\r\n      },\r\n    )\r\n  }\r\n}\r\n\r\nexport type AccountTypeNotSupportedErrorType = AccountTypeNotSupportedError & {\r\n  name: 'AccountTypeNotSupportedError'\r\n}\r\nexport class AccountTypeNotSupportedError extends BaseError {\r\n  constructor({\r\n    docsPath,\r\n    metaMessages,\r\n    type,\r\n  }: {\r\n    docsPath?: string | undefined\r\n    metaMessages?: string[] | undefined\r\n    type: string\r\n  }) {\r\n    super(`Account type \"${type}\" is not supported.`, {\r\n      docsPath,\r\n      metaMessages,\r\n      name: 'AccountTypeNotSupportedError',\r\n    })\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["sha256", "sha256", "size", "size", "blobs", "commitments", "proofs", "v"]
}
