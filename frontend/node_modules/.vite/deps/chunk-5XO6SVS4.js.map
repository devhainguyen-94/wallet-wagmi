{
  "version": 3,
  "sources": ["../../abitype/src/version.ts", "../../abitype/src/errors.ts", "../../abitype/src/human-readable/errors/abiItem.ts", "../../abitype/src/human-readable/errors/abiParameter.ts", "../../abitype/src/human-readable/errors/signature.ts", "../../abitype/src/human-readable/errors/struct.ts", "../../abitype/src/human-readable/errors/splitParameters.ts", "../../abitype/src/regex.ts", "../../abitype/src/human-readable/runtime/signatures.ts", "../../abitype/src/human-readable/runtime/cache.ts", "../../abitype/src/human-readable/runtime/utils.ts", "../../abitype/src/human-readable/runtime/structs.ts", "../../abitype/src/human-readable/parseAbi.ts", "../../abitype/src/human-readable/parseAbiItem.ts", "../../abitype/src/human-readable/parseAbiParameter.ts", "../../abitype/src/human-readable/parseAbiParameters.ts", "../../abitype/src/human-readable/formatAbiParameter.ts", "../../abitype/src/human-readable/formatAbiParameters.ts", "../../abitype/src/human-readable/formatAbiItem.ts", "../../abitype/src/human-readable/formatAbi.ts", "../../@noble/hashes/src/_u64.ts", "../../@noble/hashes/src/sha3.ts"],
  "sourcesContent": ["export const version = '1.0.8'\r\n", "import type { OneOf, Pretty } from './types.js'\r\nimport { version } from './version.js'\r\n\r\ntype BaseErrorArgs = Pretty<\r\n  {\r\n    docsPath?: string | undefined\r\n    metaMessages?: string[] | undefined\r\n  } & OneOf<{ details?: string | undefined } | { cause?: BaseError | Error }>\r\n>\r\n\r\nexport class BaseError extends Error {\r\n  details: string\r\n  docsPath?: string | undefined\r\n  metaMessages?: string[] | undefined\r\n  shortMessage: string\r\n\r\n  override name = 'AbiTypeError'\r\n\r\n  constructor(shortMessage: string, args: BaseErrorArgs = {}) {\r\n    const details =\r\n      args.cause instanceof BaseError\r\n        ? args.cause.details\r\n        : args.cause?.message\r\n          ? args.cause.message\r\n          : args.details!\r\n    const docsPath =\r\n      args.cause instanceof BaseError\r\n        ? args.cause.docsPath || args.docsPath\r\n        : args.docsPath\r\n    const message = [\r\n      shortMessage || 'An error occurred.',\r\n      '',\r\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\r\n      ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\r\n      ...(details ? [`Details: ${details}`] : []),\r\n      `Version: abitype@${version}`,\r\n    ].join('\\n')\r\n\r\n    super(message)\r\n\r\n    if (args.cause) this.cause = args.cause\r\n    this.details = details\r\n    this.docsPath = docsPath\r\n    this.metaMessages = args.metaMessages\r\n    this.shortMessage = shortMessage\r\n  }\r\n}\r\n", "import { BaseError } from '../../errors.js'\r\n\r\nexport class InvalidAbiItemError extends BaseError {\r\n  override name = 'InvalidAbiItemError'\r\n\r\n  constructor({ signature }: { signature: string | object }) {\r\n    super('Failed to parse ABI item.', {\r\n      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\r\n      docsPath: '/api/human#parseabiitem-1',\r\n    })\r\n  }\r\n}\r\n\r\nexport class UnknownTypeError extends BaseError {\r\n  override name = 'UnknownTypeError'\r\n\r\n  constructor({ type }: { type: string }) {\r\n    super('Unknown type.', {\r\n      metaMessages: [\r\n        `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\r\n      ],\r\n    })\r\n  }\r\n}\r\n\r\nexport class UnknownSolidityTypeError extends BaseError {\r\n  override name = 'UnknownSolidityTypeError'\r\n\r\n  constructor({ type }: { type: string }) {\r\n    super('Unknown type.', {\r\n      metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\r\n    })\r\n  }\r\n}\r\n", "import type { AbiItemType, AbiParameter } from '../../abi.js'\r\nimport { BaseError } from '../../errors.js'\r\nimport type { Modifier } from '../types/signatures.js'\r\n\r\nexport class InvalidAbiParameterError extends BaseError {\r\n  override name = 'InvalidAbiParameterError'\r\n\r\n  constructor({ param }: { param: string | object }) {\r\n    super('Failed to parse ABI parameter.', {\r\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\r\n      docsPath: '/api/human#parseabiparameter-1',\r\n    })\r\n  }\r\n}\r\n\r\nexport class InvalidAbiParametersError extends BaseError {\r\n  override name = 'InvalidAbiParametersError'\r\n\r\n  constructor({ params }: { params: string | object }) {\r\n    super('Failed to parse ABI parameters.', {\r\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\r\n      docsPath: '/api/human#parseabiparameters-1',\r\n    })\r\n  }\r\n}\r\n\r\nexport class InvalidParameterError extends BaseError {\r\n  override name = 'InvalidParameterError'\r\n\r\n  constructor({ param }: { param: string }) {\r\n    super('Invalid ABI parameter.', {\r\n      details: param,\r\n    })\r\n  }\r\n}\r\n\r\nexport class SolidityProtectedKeywordError extends BaseError {\r\n  override name = 'SolidityProtectedKeywordError'\r\n\r\n  constructor({ param, name }: { param: string; name: string }) {\r\n    super('Invalid ABI parameter.', {\r\n      details: param,\r\n      metaMessages: [\r\n        `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\r\n      ],\r\n    })\r\n  }\r\n}\r\n\r\nexport class InvalidModifierError extends BaseError {\r\n  override name = 'InvalidModifierError'\r\n\r\n  constructor({\r\n    param,\r\n    type,\r\n    modifier,\r\n  }: {\r\n    param: string\r\n    type?: AbiItemType | 'struct' | undefined\r\n    modifier: Modifier\r\n  }) {\r\n    super('Invalid ABI parameter.', {\r\n      details: param,\r\n      metaMessages: [\r\n        `Modifier \"${modifier}\" not allowed${\r\n          type ? ` in \"${type}\" type` : ''\r\n        }.`,\r\n      ],\r\n    })\r\n  }\r\n}\r\n\r\nexport class InvalidFunctionModifierError extends BaseError {\r\n  override name = 'InvalidFunctionModifierError'\r\n\r\n  constructor({\r\n    param,\r\n    type,\r\n    modifier,\r\n  }: {\r\n    param: string\r\n    type?: AbiItemType | 'struct' | undefined\r\n    modifier: Modifier\r\n  }) {\r\n    super('Invalid ABI parameter.', {\r\n      details: param,\r\n      metaMessages: [\r\n        `Modifier \"${modifier}\" not allowed${\r\n          type ? ` in \"${type}\" type` : ''\r\n        }.`,\r\n        `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\r\n      ],\r\n    })\r\n  }\r\n}\r\n\r\nexport class InvalidAbiTypeParameterError extends BaseError {\r\n  override name = 'InvalidAbiTypeParameterError'\r\n\r\n  constructor({\r\n    abiParameter,\r\n  }: {\r\n    abiParameter: AbiParameter & { indexed?: boolean | undefined }\r\n  }) {\r\n    super('Invalid ABI parameter.', {\r\n      details: JSON.stringify(abiParameter, null, 2),\r\n      metaMessages: ['ABI parameter type is invalid.'],\r\n    })\r\n  }\r\n}\r\n", "import type { AbiItemType } from '../../abi.js'\r\nimport { BaseError } from '../../errors.js'\r\n\r\nexport class InvalidSignatureError extends BaseError {\r\n  override name = 'InvalidSignatureError'\r\n\r\n  constructor({\r\n    signature,\r\n    type,\r\n  }: {\r\n    signature: string\r\n    type: AbiItemType | 'struct'\r\n  }) {\r\n    super(`Invalid ${type} signature.`, {\r\n      details: signature,\r\n    })\r\n  }\r\n}\r\n\r\nexport class UnknownSignatureError extends BaseError {\r\n  override name = 'UnknownSignatureError'\r\n\r\n  constructor({ signature }: { signature: string }) {\r\n    super('Unknown signature.', {\r\n      details: signature,\r\n    })\r\n  }\r\n}\r\n\r\nexport class InvalidStructSignatureError extends BaseError {\r\n  override name = 'InvalidStructSignatureError'\r\n\r\n  constructor({ signature }: { signature: string }) {\r\n    super('Invalid struct signature.', {\r\n      details: signature,\r\n      metaMessages: ['No properties exist.'],\r\n    })\r\n  }\r\n}\r\n", "import { BaseError } from '../../errors.js'\r\n\r\nexport class CircularReferenceError extends BaseError {\r\n  override name = 'CircularReferenceError'\r\n\r\n  constructor({ type }: { type: string }) {\r\n    super('Circular reference detected.', {\r\n      metaMessages: [`Struct \"${type}\" is a circular reference.`],\r\n    })\r\n  }\r\n}\r\n", "import { BaseError } from '../../errors.js'\r\n\r\nexport class InvalidParenthesisError extends BaseError {\r\n  override name = 'InvalidParenthesisError'\r\n\r\n  constructor({ current, depth }: { current: string; depth: number }) {\r\n    super('Unbalanced parentheses.', {\r\n      metaMessages: [\r\n        `\"${current.trim()}\" has too many ${\r\n          depth > 0 ? 'opening' : 'closing'\r\n        } parentheses.`,\r\n      ],\r\n      details: `Depth \"${depth}\"`,\r\n    })\r\n  }\r\n}\r\n", "// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\r\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\r\nexport function execTyped<type>(regex: RegExp, string: string) {\r\n  const match = regex.exec(string)\r\n  return match?.groups as type | undefined\r\n}\r\n\r\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\r\n// https://regexr.com/6va55\r\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\r\n\r\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\r\n// https://regexr.com/6v8hp\r\nexport const integerRegex =\r\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\r\n\r\nexport const isTupleRegex = /^\\(.+?\\).*?$/\r\n", "import type { AbiStateMutability } from '../../abi.js'\r\nimport { execTyped } from '../../regex.js'\r\nimport type {\r\n  EventModifier,\r\n  FunctionModifier,\r\n  Modifier,\r\n} from '../types/signatures.js'\r\n\r\n// https://regexr.com/7gmok\r\nconst errorSignatureRegex =\r\n  /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\r\nexport function isErrorSignature(signature: string) {\r\n  return errorSignatureRegex.test(signature)\r\n}\r\nexport function execErrorSignature(signature: string) {\r\n  return execTyped<{ name: string; parameters: string }>(\r\n    errorSignatureRegex,\r\n    signature,\r\n  )\r\n}\r\n\r\n// https://regexr.com/7gmoq\r\nconst eventSignatureRegex =\r\n  /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\r\nexport function isEventSignature(signature: string) {\r\n  return eventSignatureRegex.test(signature)\r\n}\r\nexport function execEventSignature(signature: string) {\r\n  return execTyped<{ name: string; parameters: string }>(\r\n    eventSignatureRegex,\r\n    signature,\r\n  )\r\n}\r\n\r\n// https://regexr.com/7gmot\r\nconst functionSignatureRegex =\r\n  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/\r\nexport function isFunctionSignature(signature: string) {\r\n  return functionSignatureRegex.test(signature)\r\n}\r\nexport function execFunctionSignature(signature: string) {\r\n  return execTyped<{\r\n    name: string\r\n    parameters: string\r\n    stateMutability?: AbiStateMutability\r\n    returns?: string\r\n  }>(functionSignatureRegex, signature)\r\n}\r\n\r\n// https://regexr.com/7gmp3\r\nconst structSignatureRegex =\r\n  /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/\r\nexport function isStructSignature(signature: string) {\r\n  return structSignatureRegex.test(signature)\r\n}\r\nexport function execStructSignature(signature: string) {\r\n  return execTyped<{ name: string; properties: string }>(\r\n    structSignatureRegex,\r\n    signature,\r\n  )\r\n}\r\n\r\n// https://regexr.com/78u01\r\nconst constructorSignatureRegex =\r\n  /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/\r\nexport function isConstructorSignature(signature: string) {\r\n  return constructorSignatureRegex.test(signature)\r\n}\r\nexport function execConstructorSignature(signature: string) {\r\n  return execTyped<{\r\n    parameters: string\r\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\r\n  }>(constructorSignatureRegex, signature)\r\n}\r\n\r\n// https://regexr.com/7srtn\r\nconst fallbackSignatureRegex =\r\n  /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/\r\nexport function isFallbackSignature(signature: string) {\r\n  return fallbackSignatureRegex.test(signature)\r\n}\r\nexport function execFallbackSignature(signature: string) {\r\n  return execTyped<{\r\n    parameters: string\r\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\r\n  }>(fallbackSignatureRegex, signature)\r\n}\r\n\r\n// https://regexr.com/78u1k\r\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/\r\nexport function isReceiveSignature(signature: string) {\r\n  return receiveSignatureRegex.test(signature)\r\n}\r\n\r\nexport const modifiers = new Set<Modifier>([\r\n  'memory',\r\n  'indexed',\r\n  'storage',\r\n  'calldata',\r\n])\r\nexport const eventModifiers = new Set<EventModifier>(['indexed'])\r\nexport const functionModifiers = new Set<FunctionModifier>([\r\n  'calldata',\r\n  'memory',\r\n  'storage',\r\n])\r\n", "import type { AbiItemType, AbiParameter } from '../../abi.js'\r\nimport type { StructLookup } from '../types/structs.js'\r\n\r\n/**\r\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\r\n * @param param ABI parameter string\r\n * @param type ABI parameter type\r\n * @returns Cache key for {@link parameterCache}\r\n */\r\nexport function getParameterCacheKey(\r\n  param: string,\r\n  type?: AbiItemType | 'struct',\r\n  structs?: StructLookup,\r\n) {\r\n  let structKey = ''\r\n  if (structs)\r\n    for (const struct of Object.entries(structs)) {\r\n      if (!struct) continue\r\n      let propertyKey = ''\r\n      for (const property of struct[1]) {\r\n        propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`\r\n      }\r\n      structKey += `(${struct[0]}{${propertyKey}})`\r\n    }\r\n  if (type) return `${type}:${param}${structKey}`\r\n  return param\r\n}\r\n\r\n/**\r\n * Basic cache seeded with common ABI parameter strings.\r\n *\r\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\r\n */\r\nexport const parameterCache = new Map<\r\n  string,\r\n  AbiParameter & { indexed?: boolean }\r\n>([\r\n  // Unnamed\r\n  ['address', { type: 'address' }],\r\n  ['bool', { type: 'bool' }],\r\n  ['bytes', { type: 'bytes' }],\r\n  ['bytes32', { type: 'bytes32' }],\r\n  ['int', { type: 'int256' }],\r\n  ['int256', { type: 'int256' }],\r\n  ['string', { type: 'string' }],\r\n  ['uint', { type: 'uint256' }],\r\n  ['uint8', { type: 'uint8' }],\r\n  ['uint16', { type: 'uint16' }],\r\n  ['uint24', { type: 'uint24' }],\r\n  ['uint32', { type: 'uint32' }],\r\n  ['uint64', { type: 'uint64' }],\r\n  ['uint96', { type: 'uint96' }],\r\n  ['uint112', { type: 'uint112' }],\r\n  ['uint160', { type: 'uint160' }],\r\n  ['uint192', { type: 'uint192' }],\r\n  ['uint256', { type: 'uint256' }],\r\n\r\n  // Named\r\n  ['address owner', { type: 'address', name: 'owner' }],\r\n  ['address to', { type: 'address', name: 'to' }],\r\n  ['bool approved', { type: 'bool', name: 'approved' }],\r\n  ['bytes _data', { type: 'bytes', name: '_data' }],\r\n  ['bytes data', { type: 'bytes', name: 'data' }],\r\n  ['bytes signature', { type: 'bytes', name: 'signature' }],\r\n  ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\r\n  ['bytes32 r', { type: 'bytes32', name: 'r' }],\r\n  ['bytes32 root', { type: 'bytes32', name: 'root' }],\r\n  ['bytes32 s', { type: 'bytes32', name: 's' }],\r\n  ['string name', { type: 'string', name: 'name' }],\r\n  ['string symbol', { type: 'string', name: 'symbol' }],\r\n  ['string tokenURI', { type: 'string', name: 'tokenURI' }],\r\n  ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\r\n  ['uint8 v', { type: 'uint8', name: 'v' }],\r\n  ['uint256 balance', { type: 'uint256', name: 'balance' }],\r\n  ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\r\n  ['uint256 value', { type: 'uint256', name: 'value' }],\r\n\r\n  // Indexed\r\n  [\r\n    'event:address indexed from',\r\n    { type: 'address', name: 'from', indexed: true },\r\n  ],\r\n  ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\r\n  [\r\n    'event:uint indexed tokenId',\r\n    { type: 'uint256', name: 'tokenId', indexed: true },\r\n  ],\r\n  [\r\n    'event:uint256 indexed tokenId',\r\n    { type: 'uint256', name: 'tokenId', indexed: true },\r\n  ],\r\n])\r\n", "import type {\r\n  AbiItemType,\r\n  AbiType,\r\n  SolidityArray,\r\n  SolidityBytes,\r\n  SolidityString,\r\n  SolidityTuple,\r\n} from '../../abi.js'\r\nimport {\r\n  bytesRegex,\r\n  execTyped,\r\n  integerRegex,\r\n  isTupleRegex,\r\n} from '../../regex.js'\r\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js'\r\nimport {\r\n  InvalidFunctionModifierError,\r\n  InvalidModifierError,\r\n  InvalidParameterError,\r\n  SolidityProtectedKeywordError,\r\n} from '../errors/abiParameter.js'\r\nimport {\r\n  InvalidSignatureError,\r\n  UnknownSignatureError,\r\n} from '../errors/signature.js'\r\nimport { InvalidParenthesisError } from '../errors/splitParameters.js'\r\nimport type { FunctionModifier, Modifier } from '../types/signatures.js'\r\nimport type { StructLookup } from '../types/structs.js'\r\nimport { getParameterCacheKey, parameterCache } from './cache.js'\r\nimport {\r\n  eventModifiers,\r\n  execConstructorSignature,\r\n  execErrorSignature,\r\n  execEventSignature,\r\n  execFallbackSignature,\r\n  execFunctionSignature,\r\n  functionModifiers,\r\n  isConstructorSignature,\r\n  isErrorSignature,\r\n  isEventSignature,\r\n  isFallbackSignature,\r\n  isFunctionSignature,\r\n  isReceiveSignature,\r\n} from './signatures.js'\r\n\r\nexport function parseSignature(signature: string, structs: StructLookup = {}) {\r\n  if (isFunctionSignature(signature))\r\n    return parseFunctionSignature(signature, structs)\r\n\r\n  if (isEventSignature(signature))\r\n    return parseEventSignature(signature, structs)\r\n\r\n  if (isErrorSignature(signature))\r\n    return parseErrorSignature(signature, structs)\r\n\r\n  if (isConstructorSignature(signature))\r\n    return parseConstructorSignature(signature, structs)\r\n\r\n  if (isFallbackSignature(signature)) return parseFallbackSignature(signature)\r\n\r\n  if (isReceiveSignature(signature))\r\n    return {\r\n      type: 'receive',\r\n      stateMutability: 'payable',\r\n    }\r\n\r\n  throw new UnknownSignatureError({ signature })\r\n}\r\n\r\nexport function parseFunctionSignature(\r\n  signature: string,\r\n  structs: StructLookup = {},\r\n) {\r\n  const match = execFunctionSignature(signature)\r\n  if (!match) throw new InvalidSignatureError({ signature, type: 'function' })\r\n\r\n  const inputParams = splitParameters(match.parameters)\r\n  const inputs = []\r\n  const inputLength = inputParams.length\r\n  for (let i = 0; i < inputLength; i++) {\r\n    inputs.push(\r\n      parseAbiParameter(inputParams[i]!, {\r\n        modifiers: functionModifiers,\r\n        structs,\r\n        type: 'function',\r\n      }),\r\n    )\r\n  }\r\n\r\n  const outputs = []\r\n  if (match.returns) {\r\n    const outputParams = splitParameters(match.returns)\r\n    const outputLength = outputParams.length\r\n    for (let i = 0; i < outputLength; i++) {\r\n      outputs.push(\r\n        parseAbiParameter(outputParams[i]!, {\r\n          modifiers: functionModifiers,\r\n          structs,\r\n          type: 'function',\r\n        }),\r\n      )\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: match.name,\r\n    type: 'function',\r\n    stateMutability: match.stateMutability ?? 'nonpayable',\r\n    inputs,\r\n    outputs,\r\n  }\r\n}\r\n\r\nexport function parseEventSignature(\r\n  signature: string,\r\n  structs: StructLookup = {},\r\n) {\r\n  const match = execEventSignature(signature)\r\n  if (!match) throw new InvalidSignatureError({ signature, type: 'event' })\r\n\r\n  const params = splitParameters(match.parameters)\r\n  const abiParameters = []\r\n  const length = params.length\r\n  for (let i = 0; i < length; i++)\r\n    abiParameters.push(\r\n      parseAbiParameter(params[i]!, {\r\n        modifiers: eventModifiers,\r\n        structs,\r\n        type: 'event',\r\n      }),\r\n    )\r\n  return { name: match.name, type: 'event', inputs: abiParameters }\r\n}\r\n\r\nexport function parseErrorSignature(\r\n  signature: string,\r\n  structs: StructLookup = {},\r\n) {\r\n  const match = execErrorSignature(signature)\r\n  if (!match) throw new InvalidSignatureError({ signature, type: 'error' })\r\n\r\n  const params = splitParameters(match.parameters)\r\n  const abiParameters = []\r\n  const length = params.length\r\n  for (let i = 0; i < length; i++)\r\n    abiParameters.push(\r\n      parseAbiParameter(params[i]!, { structs, type: 'error' }),\r\n    )\r\n  return { name: match.name, type: 'error', inputs: abiParameters }\r\n}\r\n\r\nexport function parseConstructorSignature(\r\n  signature: string,\r\n  structs: StructLookup = {},\r\n) {\r\n  const match = execConstructorSignature(signature)\r\n  if (!match)\r\n    throw new InvalidSignatureError({ signature, type: 'constructor' })\r\n\r\n  const params = splitParameters(match.parameters)\r\n  const abiParameters = []\r\n  const length = params.length\r\n  for (let i = 0; i < length; i++)\r\n    abiParameters.push(\r\n      parseAbiParameter(params[i]!, { structs, type: 'constructor' }),\r\n    )\r\n  return {\r\n    type: 'constructor',\r\n    stateMutability: match.stateMutability ?? 'nonpayable',\r\n    inputs: abiParameters,\r\n  }\r\n}\r\n\r\nexport function parseFallbackSignature(signature: string) {\r\n  const match = execFallbackSignature(signature)\r\n  if (!match) throw new InvalidSignatureError({ signature, type: 'fallback' })\r\n\r\n  return {\r\n    type: 'fallback',\r\n    stateMutability: match.stateMutability ?? 'nonpayable',\r\n  }\r\n}\r\n\r\nconst abiParameterWithoutTupleRegex =\r\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\r\nconst abiParameterWithTupleRegex =\r\n  /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\r\nconst dynamicIntegerRegex = /^u?int$/\r\n\r\ntype ParseOptions = {\r\n  modifiers?: Set<Modifier>\r\n  structs?: StructLookup\r\n  type?: AbiItemType | 'struct'\r\n}\r\n\r\nexport function parseAbiParameter(param: string, options?: ParseOptions) {\r\n  // optional namespace cache by `type`\r\n  const parameterCacheKey = getParameterCacheKey(\r\n    param,\r\n    options?.type,\r\n    options?.structs,\r\n  )\r\n  if (parameterCache.has(parameterCacheKey))\r\n    return parameterCache.get(parameterCacheKey)!\r\n\r\n  const isTuple = isTupleRegex.test(param)\r\n  const match = execTyped<{\r\n    array?: string\r\n    modifier?: Modifier\r\n    name?: string\r\n    type: string\r\n  }>(\r\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\r\n    param,\r\n  )\r\n  if (!match) throw new InvalidParameterError({ param })\r\n\r\n  if (match.name && isSolidityKeyword(match.name))\r\n    throw new SolidityProtectedKeywordError({ param, name: match.name })\r\n\r\n  const name = match.name ? { name: match.name } : {}\r\n  const indexed = match.modifier === 'indexed' ? { indexed: true } : {}\r\n  const structs = options?.structs ?? {}\r\n  let type: string\r\n  let components = {}\r\n  if (isTuple) {\r\n    type = 'tuple'\r\n    const params = splitParameters(match.type)\r\n    const components_ = []\r\n    const length = params.length\r\n    for (let i = 0; i < length; i++) {\r\n      // remove `modifiers` from `options` to prevent from being added to tuple components\r\n      components_.push(parseAbiParameter(params[i]!, { structs }))\r\n    }\r\n    components = { components: components_ }\r\n  } else if (match.type in structs) {\r\n    type = 'tuple'\r\n    components = { components: structs[match.type] }\r\n  } else if (dynamicIntegerRegex.test(match.type)) {\r\n    type = `${match.type}256`\r\n  } else {\r\n    type = match.type\r\n    if (!(options?.type === 'struct') && !isSolidityType(type))\r\n      throw new UnknownSolidityTypeError({ type })\r\n  }\r\n\r\n  if (match.modifier) {\r\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\r\n    if (!options?.modifiers?.has?.(match.modifier))\r\n      throw new InvalidModifierError({\r\n        param,\r\n        type: options?.type,\r\n        modifier: match.modifier,\r\n      })\r\n\r\n    // Check if resolved `type` is valid if there is a function modifier\r\n    if (\r\n      functionModifiers.has(match.modifier as FunctionModifier) &&\r\n      !isValidDataLocation(type, !!match.array)\r\n    )\r\n      throw new InvalidFunctionModifierError({\r\n        param,\r\n        type: options?.type,\r\n        modifier: match.modifier,\r\n      })\r\n  }\r\n\r\n  const abiParameter = {\r\n    type: `${type}${match.array ?? ''}`,\r\n    ...name,\r\n    ...indexed,\r\n    ...components,\r\n  }\r\n  parameterCache.set(parameterCacheKey, abiParameter)\r\n  return abiParameter\r\n}\r\n\r\n// s/o latika for this\r\nexport function splitParameters(\r\n  params: string,\r\n  result: string[] = [],\r\n  current = '',\r\n  depth = 0,\r\n): readonly string[] {\r\n  const length = params.trim().length\r\n  // biome-ignore lint/correctness/noUnreachable: recursive\r\n  for (let i = 0; i < length; i++) {\r\n    const char = params[i]\r\n    const tail = params.slice(i + 1)\r\n    switch (char) {\r\n      case ',':\r\n        return depth === 0\r\n          ? splitParameters(tail, [...result, current.trim()])\r\n          : splitParameters(tail, result, `${current}${char}`, depth)\r\n      case '(':\r\n        return splitParameters(tail, result, `${current}${char}`, depth + 1)\r\n      case ')':\r\n        return splitParameters(tail, result, `${current}${char}`, depth - 1)\r\n      default:\r\n        return splitParameters(tail, result, `${current}${char}`, depth)\r\n    }\r\n  }\r\n\r\n  if (current === '') return result\r\n  if (depth !== 0) throw new InvalidParenthesisError({ current, depth })\r\n\r\n  result.push(current.trim())\r\n  return result\r\n}\r\n\r\nexport function isSolidityType(\r\n  type: string,\r\n): type is Exclude<AbiType, SolidityTuple | SolidityArray> {\r\n  return (\r\n    type === 'address' ||\r\n    type === 'bool' ||\r\n    type === 'function' ||\r\n    type === 'string' ||\r\n    bytesRegex.test(type) ||\r\n    integerRegex.test(type)\r\n  )\r\n}\r\n\r\nconst protectedKeywordsRegex =\r\n  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/\r\n\r\n/** @internal */\r\nexport function isSolidityKeyword(name: string) {\r\n  return (\r\n    name === 'address' ||\r\n    name === 'bool' ||\r\n    name === 'function' ||\r\n    name === 'string' ||\r\n    name === 'tuple' ||\r\n    bytesRegex.test(name) ||\r\n    integerRegex.test(name) ||\r\n    protectedKeywordsRegex.test(name)\r\n  )\r\n}\r\n\r\n/** @internal */\r\nexport function isValidDataLocation(\r\n  type: string,\r\n  isArray: boolean,\r\n): type is Exclude<\r\n  AbiType,\r\n  SolidityString | Extract<SolidityBytes, 'bytes'> | SolidityArray\r\n> {\r\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple'\r\n}\r\n", "import type { AbiParameter } from '../../abi.js'\r\nimport { execTyped, isTupleRegex } from '../../regex.js'\r\nimport { UnknownTypeError } from '../errors/abiItem.js'\r\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\r\nimport {\r\n  InvalidSignatureError,\r\n  InvalidStructSignatureError,\r\n} from '../errors/signature.js'\r\nimport { CircularReferenceError } from '../errors/struct.js'\r\nimport type { StructLookup } from '../types/structs.js'\r\nimport { execStructSignature, isStructSignature } from './signatures.js'\r\nimport { isSolidityType, parseAbiParameter } from './utils.js'\r\n\r\nexport function parseStructs(signatures: readonly string[]) {\r\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\r\n  const shallowStructs: StructLookup = {}\r\n  const signaturesLength = signatures.length\r\n  for (let i = 0; i < signaturesLength; i++) {\r\n    const signature = signatures[i]!\r\n    if (!isStructSignature(signature)) continue\r\n\r\n    const match = execStructSignature(signature)\r\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\r\n\r\n    const properties = match.properties.split(';')\r\n\r\n    const components: AbiParameter[] = []\r\n    const propertiesLength = properties.length\r\n    for (let k = 0; k < propertiesLength; k++) {\r\n      const property = properties[k]!\r\n      const trimmed = property.trim()\r\n      if (!trimmed) continue\r\n      const abiParameter = parseAbiParameter(trimmed, {\r\n        type: 'struct',\r\n      })\r\n      components.push(abiParameter)\r\n    }\r\n\r\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\r\n    shallowStructs[match.name] = components\r\n  }\r\n\r\n  // Resolve nested structs inside each parameter\r\n  const resolvedStructs: StructLookup = {}\r\n  const entries = Object.entries(shallowStructs)\r\n  const entriesLength = entries.length\r\n  for (let i = 0; i < entriesLength; i++) {\r\n    const [name, parameters] = entries[i]!\r\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\r\n  }\r\n\r\n  return resolvedStructs\r\n}\r\n\r\nconst typeWithoutTupleRegex =\r\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\r\n\r\nfunction resolveStructs(\r\n  abiParameters: readonly (AbiParameter & { indexed?: true })[],\r\n  structs: StructLookup,\r\n  ancestors = new Set<string>(),\r\n) {\r\n  const components: AbiParameter[] = []\r\n  const length = abiParameters.length\r\n  for (let i = 0; i < length; i++) {\r\n    const abiParameter = abiParameters[i]!\r\n    const isTuple = isTupleRegex.test(abiParameter.type)\r\n    if (isTuple) components.push(abiParameter)\r\n    else {\r\n      const match = execTyped<{ array?: string; type: string }>(\r\n        typeWithoutTupleRegex,\r\n        abiParameter.type,\r\n      )\r\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\r\n\r\n      const { array, type } = match\r\n      if (type in structs) {\r\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\r\n\r\n        components.push({\r\n          ...abiParameter,\r\n          type: `tuple${array ?? ''}`,\r\n          components: resolveStructs(\r\n            structs[type] ?? [],\r\n            structs,\r\n            new Set([...ancestors, type]),\r\n          ),\r\n        })\r\n      } else {\r\n        if (isSolidityType(type)) components.push(abiParameter)\r\n        else throw new UnknownTypeError({ type })\r\n      }\r\n    }\r\n  }\r\n\r\n  return components\r\n}\r\n", "import type { Abi } from '../abi.js'\r\nimport type { Error, Filter } from '../types.js'\r\nimport { isStructSignature } from './runtime/signatures.js'\r\nimport { parseStructs } from './runtime/structs.js'\r\nimport { parseSignature } from './runtime/utils.js'\r\nimport type { Signatures } from './types/signatures.js'\r\nimport type { ParseStructs } from './types/structs.js'\r\nimport type { ParseSignature } from './types/utils.js'\r\n\r\n/**\r\n * Parses human-readable ABI into JSON {@link Abi}\r\n *\r\n * @param signatures - Human-readable ABI\r\n * @returns Parsed {@link Abi}\r\n *\r\n * @example\r\n * type Result = ParseAbi<\r\n *   // ^? type Result = readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\r\n *   [\r\n *     'function balanceOf(address owner) view returns (uint256)',\r\n *     'event Transfer(address indexed from, address indexed to, uint256 amount)',\r\n *   ]\r\n * >\r\n */\r\nexport type ParseAbi<signatures extends readonly string[]> =\r\n  string[] extends signatures\r\n    ? Abi // If `T` was not able to be inferred (e.g. just `string[]`), return `Abi`\r\n    : signatures extends readonly string[]\r\n      ? signatures extends Signatures<signatures> // Validate signatures\r\n        ? ParseStructs<signatures> extends infer sructs\r\n          ? {\r\n              [key in keyof signatures]: signatures[key] extends string\r\n                ? ParseSignature<signatures[key], sructs>\r\n                : never\r\n            } extends infer mapped extends readonly unknown[]\r\n            ? Filter<mapped, never> extends infer result\r\n              ? result extends readonly []\r\n                ? never\r\n                : result\r\n              : never\r\n            : never\r\n          : never\r\n        : never\r\n      : never\r\n\r\n/**\r\n * Parses human-readable ABI into JSON {@link Abi}\r\n *\r\n * @param signatures - Human-Readable ABI\r\n * @returns Parsed {@link Abi}\r\n *\r\n * @example\r\n * const abi = parseAbi([\r\n *   //  ^? const abi: readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\r\n *   'function balanceOf(address owner) view returns (uint256)',\r\n *   'event Transfer(address indexed from, address indexed to, uint256 amount)',\r\n * ])\r\n */\r\nexport function parseAbi<const signatures extends readonly string[]>(\r\n  signatures: signatures['length'] extends 0\r\n    ? Error<'At least one signature required'>\r\n    : Signatures<signatures> extends signatures\r\n      ? signatures\r\n      : Signatures<signatures>,\r\n): ParseAbi<signatures> {\r\n  const structs = parseStructs(signatures as readonly string[])\r\n  const abi = []\r\n  const length = signatures.length as number\r\n  for (let i = 0; i < length; i++) {\r\n    const signature = (signatures as readonly string[])[i]!\r\n    if (isStructSignature(signature)) continue\r\n    abi.push(parseSignature(signature, structs))\r\n  }\r\n  return abi as unknown as ParseAbi<signatures>\r\n}\r\n", "import type { Abi } from '../abi.js'\r\nimport type { Narrow } from '../narrow.js'\r\nimport type { Error, Filter } from '../types.js'\r\nimport { InvalidAbiItemError } from './errors/abiItem.js'\r\nimport { isStructSignature } from './runtime/signatures.js'\r\nimport { parseStructs } from './runtime/structs.js'\r\nimport { parseSignature } from './runtime/utils.js'\r\nimport type { Signature, Signatures } from './types/signatures.js'\r\nimport type { ParseStructs } from './types/structs.js'\r\nimport type { ParseSignature } from './types/utils.js'\r\n\r\n/**\r\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\r\n *\r\n * @param signature - Human-readable ABI item\r\n * @returns Parsed {@link Abi} item\r\n *\r\n * @example\r\n * type Result = ParseAbiItem<'function balanceOf(address owner) view returns (uint256)'>\r\n * //   ^? type Result = { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\r\n *\r\n * @example\r\n * type Result = ParseAbiItem<\r\n *   // ^? type Result = { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\r\n *   ['function foo(Baz bar) view returns (string)', 'struct Baz { string name; }']\r\n * >\r\n */\r\nexport type ParseAbiItem<\r\n  signature extends string | readonly string[] | readonly unknown[],\r\n> =\r\n  | (signature extends string\r\n      ? string extends signature\r\n        ? Abi[number]\r\n        : signature extends Signature<signature> // Validate signature\r\n          ? ParseSignature<signature>\r\n          : never\r\n      : never)\r\n  | (signature extends readonly string[]\r\n      ? string[] extends signature\r\n        ? Abi[number] // Return generic Abi item since type was no inferrable\r\n        : signature extends Signatures<signature> // Validate signature\r\n          ? ParseStructs<signature> extends infer structs\r\n            ? {\r\n                [key in keyof signature]: ParseSignature<\r\n                  signature[key] extends string ? signature[key] : never,\r\n                  structs\r\n                >\r\n              } extends infer mapped extends readonly unknown[]\r\n              ? // Filter out `never` since those are structs\r\n                Filter<mapped, never>[0] extends infer result\r\n                ? result extends undefined // convert `undefined` to `never` (e.g. `ParseAbiItem<['struct Foo { string name; }']>`)\r\n                  ? never\r\n                  : result\r\n                : never\r\n              : never\r\n            : never\r\n          : never\r\n      : never)\r\n\r\n/**\r\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\r\n *\r\n * @param signature - Human-readable ABI item\r\n * @returns Parsed {@link Abi} item\r\n *\r\n * @example\r\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\r\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\r\n *\r\n * @example\r\n * const abiItem = parseAbiItem([\r\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\r\n *   'function foo(Baz bar) view returns (string)',\r\n *   'struct Baz { string name; }',\r\n * ])\r\n */\r\nexport function parseAbiItem<\r\n  signature extends string | readonly string[] | readonly unknown[],\r\n>(\r\n  signature: Narrow<signature> &\r\n    (\r\n      | (signature extends string\r\n          ? string extends signature\r\n            ? unknown\r\n            : Signature<signature>\r\n          : never)\r\n      | (signature extends readonly string[]\r\n          ? signature extends readonly [] // empty array\r\n            ? Error<'At least one signature required.'>\r\n            : string[] extends signature\r\n              ? unknown\r\n              : Signatures<signature>\r\n          : never)\r\n    ),\r\n): ParseAbiItem<signature> {\r\n  let abiItem: ParseAbiItem<signature> | undefined\r\n  if (typeof signature === 'string')\r\n    abiItem = parseSignature(signature) as ParseAbiItem<signature>\r\n  else {\r\n    const structs = parseStructs(signature as readonly string[])\r\n    const length = signature.length as number\r\n    for (let i = 0; i < length; i++) {\r\n      const signature_ = (signature as readonly string[])[i]!\r\n      if (isStructSignature(signature_)) continue\r\n      abiItem = parseSignature(signature_, structs) as ParseAbiItem<signature>\r\n      break\r\n    }\r\n  }\r\n\r\n  if (!abiItem) throw new InvalidAbiItemError({ signature })\r\n  return abiItem as ParseAbiItem<signature>\r\n}\r\n", "import type { AbiParameter } from '../abi.js'\r\nimport type { Narrow } from '../narrow.js'\r\nimport type { Error, Filter } from '../types.js'\r\nimport { InvalidAbiParameterError } from './errors/abiParameter.js'\r\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\r\nimport { parseStructs } from './runtime/structs.js'\r\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\r\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\r\nimport type { ParseStructs } from './types/structs.js'\r\nimport type { ParseAbiParameter as ParseAbiParameter_ } from './types/utils.js'\r\n\r\n/**\r\n * Parses human-readable ABI parameter into {@link AbiParameter}\r\n *\r\n * @param param - Human-readable ABI parameter\r\n * @returns Parsed {@link AbiParameter}\r\n *\r\n * @example\r\n * type Result = ParseAbiParameter<'address from'>\r\n * //   ^? type Result = { type: \"address\"; name: \"from\"; }\r\n *\r\n * @example\r\n * type Result = ParseAbiParameter<\r\n *   // ^? type Result = { type: \"tuple\"; components: [{ type: \"string\"; name:...\r\n *   ['Baz bar', 'struct Baz { string name; }']\r\n * >\r\n */\r\nexport type ParseAbiParameter<\r\n  param extends string | readonly string[] | readonly unknown[],\r\n> =\r\n  | (param extends string\r\n      ? param extends ''\r\n        ? never\r\n        : string extends param\r\n          ? AbiParameter\r\n          : ParseAbiParameter_<param, { modifier: Modifier }>\r\n      : never)\r\n  | (param extends readonly string[]\r\n      ? string[] extends param\r\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\r\n        : ParseStructs<param> extends infer structs\r\n          ? {\r\n              [key in keyof param]: param[key] extends string\r\n                ? IsStructSignature<param[key]> extends true\r\n                  ? never\r\n                  : ParseAbiParameter_<\r\n                      param[key],\r\n                      { modifier: Modifier; structs: structs }\r\n                    >\r\n                : never\r\n            } extends infer mapped extends readonly unknown[]\r\n            ? Filter<mapped, never>[0] extends infer result\r\n              ? result extends undefined\r\n                ? never\r\n                : result\r\n              : never\r\n            : never\r\n          : never\r\n      : never)\r\n\r\n/**\r\n * Parses human-readable ABI parameter into {@link AbiParameter}\r\n *\r\n * @param param - Human-readable ABI parameter\r\n * @returns Parsed {@link AbiParameter}\r\n *\r\n * @example\r\n * const abiParameter = parseAbiParameter('address from')\r\n * //    ^? const abiParameter: { type: \"address\"; name: \"from\"; }\r\n *\r\n * @example\r\n * const abiParameter = parseAbiParameter([\r\n *   //  ^? const abiParameter: { type: \"tuple\"; components: [{ type: \"string\"; name:...\r\n *   'Baz bar',\r\n *   'struct Baz { string name; }',\r\n * ])\r\n */\r\nexport function parseAbiParameter<\r\n  param extends string | readonly string[] | readonly unknown[],\r\n>(\r\n  param: Narrow<param> &\r\n    (\r\n      | (param extends string\r\n          ? param extends ''\r\n            ? Error<'Empty string is not allowed.'>\r\n            : unknown\r\n          : never)\r\n      | (param extends readonly string[]\r\n          ? param extends readonly [] // empty array\r\n            ? Error<'At least one parameter required.'>\r\n            : string[] extends param\r\n              ? unknown\r\n              : unknown // TODO: Validate param string\r\n          : never)\r\n    ),\r\n): ParseAbiParameter<param> {\r\n  let abiParameter: AbiParameter | undefined\r\n  if (typeof param === 'string')\r\n    abiParameter = parseAbiParameter_(param, {\r\n      modifiers,\r\n    }) as ParseAbiParameter<param>\r\n  else {\r\n    const structs = parseStructs(param as readonly string[])\r\n    const length = param.length as number\r\n    for (let i = 0; i < length; i++) {\r\n      const signature = (param as readonly string[])[i]!\r\n      if (isStructSignature(signature)) continue\r\n      abiParameter = parseAbiParameter_(signature, { modifiers, structs })\r\n      break\r\n    }\r\n  }\r\n\r\n  if (!abiParameter) throw new InvalidAbiParameterError({ param })\r\n\r\n  return abiParameter as ParseAbiParameter<param>\r\n}\r\n", "import type { AbiParameter } from '../abi.js'\r\nimport type { Narrow } from '../narrow.js'\r\nimport type { Error, Filter } from '../types.js'\r\nimport { InvalidAbiParametersError } from './errors/abiParameter.js'\r\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\r\nimport { parseStructs } from './runtime/structs.js'\r\nimport { splitParameters } from './runtime/utils.js'\r\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\r\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\r\nimport type { ParseStructs } from './types/structs.js'\r\nimport type { SplitParameters } from './types/utils.js'\r\nimport type { ParseAbiParameters as ParseAbiParameters_ } from './types/utils.js'\r\n\r\n/**\r\n * Parses human-readable ABI parameters into {@link AbiParameter}s\r\n *\r\n * @param params - Human-readable ABI parameters\r\n * @returns Parsed {@link AbiParameter}s\r\n *\r\n * @example\r\n * type Result = ParseAbiParameters('address from, address to, uint256 amount')\r\n * //   ^? type Result: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\r\n *\r\n * @example\r\n * type Result = ParseAbiParameters<\r\n *   // ^? type Result: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\r\n *   ['Baz bar', 'struct Baz { string name; }']\r\n * >\r\n */\r\nexport type ParseAbiParameters<\r\n  params extends string | readonly string[] | readonly unknown[],\r\n> =\r\n  | (params extends string\r\n      ? params extends ''\r\n        ? never\r\n        : string extends params\r\n          ? readonly AbiParameter[]\r\n          : ParseAbiParameters_<SplitParameters<params>, { modifier: Modifier }>\r\n      : never)\r\n  | (params extends readonly string[]\r\n      ? string[] extends params\r\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\r\n        : ParseStructs<params> extends infer structs\r\n          ? {\r\n              [key in keyof params]: params[key] extends string\r\n                ? IsStructSignature<params[key]> extends true\r\n                  ? never\r\n                  : ParseAbiParameters_<\r\n                      SplitParameters<params[key]>,\r\n                      { modifier: Modifier; structs: structs }\r\n                    >\r\n                : never\r\n            } extends infer mapped extends readonly unknown[]\r\n            ? Filter<mapped, never> extends readonly [...infer content]\r\n              ? content['length'] extends 0\r\n                ? never\r\n                : DeepFlatten<content>\r\n              : never\r\n            : never\r\n          : never\r\n      : never)\r\n\r\n/**\r\n * Flatten all members of {@link T}\r\n *\r\n * @param T - List of items to flatten\r\n * @param Acc - The accumulator used while recursing\r\n * @returns The flattened array\r\n *\r\n * @example\r\n * type Result = DeepFlatten<[['a', 'b'], [['c']]]>\r\n * //   ^? type Result = ['a', 'b', 'c']\r\n */\r\ntype DeepFlatten<\r\n  T extends readonly unknown[],\r\n  Acc extends readonly unknown[] = readonly [],\r\n> = T extends readonly [infer head, ...infer tail]\r\n  ? tail extends undefined\r\n    ? never\r\n    : head extends readonly unknown[]\r\n      ? DeepFlatten<tail, readonly [...Acc, ...DeepFlatten<head>]>\r\n      : DeepFlatten<tail, readonly [...Acc, head]>\r\n  : Acc\r\n\r\n/**\r\n * Parses human-readable ABI parameters into {@link AbiParameter}s\r\n *\r\n * @param params - Human-readable ABI parameters\r\n * @returns Parsed {@link AbiParameter}s\r\n *\r\n * @example\r\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\r\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\r\n *\r\n * @example\r\n * const abiParameters = parseAbiParameters([\r\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\r\n *   'Baz bar',\r\n *   'struct Baz { string name; }',\r\n * ])\r\n */\r\nexport function parseAbiParameters<\r\n  params extends string | readonly string[] | readonly unknown[],\r\n>(\r\n  params: Narrow<params> &\r\n    (\r\n      | (params extends string\r\n          ? params extends ''\r\n            ? Error<'Empty string is not allowed.'>\r\n            : unknown\r\n          : never)\r\n      | (params extends readonly string[]\r\n          ? params extends readonly [] // empty array\r\n            ? Error<'At least one parameter required.'>\r\n            : string[] extends params\r\n              ? unknown\r\n              : unknown // TODO: Validate param string\r\n          : never)\r\n    ),\r\n): ParseAbiParameters<params> {\r\n  const abiParameters: AbiParameter[] = []\r\n  if (typeof params === 'string') {\r\n    const parameters = splitParameters(params)\r\n    const length = parameters.length\r\n    for (let i = 0; i < length; i++) {\r\n      abiParameters.push(parseAbiParameter_(parameters[i]!, { modifiers }))\r\n    }\r\n  } else {\r\n    const structs = parseStructs(params as readonly string[])\r\n    const length = params.length as number\r\n    for (let i = 0; i < length; i++) {\r\n      const signature = (params as readonly string[])[i]!\r\n      if (isStructSignature(signature)) continue\r\n      const parameters = splitParameters(signature)\r\n      const length = parameters.length\r\n      for (let k = 0; k < length; k++) {\r\n        abiParameters.push(\r\n          parseAbiParameter_(parameters[k]!, { modifiers, structs }),\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  if (abiParameters.length === 0)\r\n    throw new InvalidAbiParametersError({ params })\r\n\r\n  return abiParameters as ParseAbiParameters<params>\r\n}\r\n", "import type { AbiEventParameter, AbiParameter } from '../abi.js'\r\nimport { execTyped } from '../regex.js'\r\nimport type { IsNarrowable, Join } from '../types.js'\r\nimport type { AssertName } from './types/signatures.js'\r\n\r\n/**\r\n * Formats {@link AbiParameter} to human-readable ABI parameter.\r\n *\r\n * @param abiParameter - ABI parameter\r\n * @returns Human-readable ABI parameter\r\n *\r\n * @example\r\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\r\n * //   ^? type Result = 'address from'\r\n */\r\nexport type FormatAbiParameter<\r\n  abiParameter extends AbiParameter | AbiEventParameter,\r\n> = abiParameter extends {\r\n  name?: infer name extends string\r\n  type: `tuple${infer array}`\r\n  components: infer components extends readonly AbiParameter[]\r\n  indexed?: infer indexed extends boolean\r\n}\r\n  ? FormatAbiParameter<\r\n      {\r\n        type: `(${Join<\r\n          {\r\n            [key in keyof components]: FormatAbiParameter<\r\n              {\r\n                type: components[key]['type']\r\n              } & (IsNarrowable<components[key]['name'], string> extends true\r\n                ? { name: components[key]['name'] }\r\n                : unknown) &\r\n                (components[key] extends { components: readonly AbiParameter[] }\r\n                  ? { components: components[key]['components'] }\r\n                  : unknown)\r\n            >\r\n          },\r\n          ', '\r\n        >})${array}`\r\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\r\n        (IsNarrowable<indexed, boolean> extends true\r\n          ? { indexed: indexed }\r\n          : unknown)\r\n    >\r\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\r\n      ? ' indexed'\r\n      : ''}${abiParameter['name'] extends infer name extends string\r\n      ? name extends ''\r\n        ? ''\r\n        : ` ${AssertName<name>}`\r\n      : ''}`\r\n\r\n// https://regexr.com/7f7rv\r\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\r\n\r\n/**\r\n * Formats {@link AbiParameter} to human-readable ABI parameter.\r\n *\r\n * @param abiParameter - ABI parameter\r\n * @returns Human-readable ABI parameter\r\n *\r\n * @example\r\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\r\n * //    ^? const result: 'address from'\r\n */\r\nexport function formatAbiParameter<\r\n  const abiParameter extends AbiParameter | AbiEventParameter,\r\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\r\n  type Result = FormatAbiParameter<abiParameter>\r\n\r\n  let type = abiParameter.type\r\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\r\n    type = '('\r\n    const length = abiParameter.components.length as number\r\n    for (let i = 0; i < length; i++) {\r\n      const component = abiParameter.components[i]!\r\n      type += formatAbiParameter(component)\r\n      if (i < length - 1) type += ', '\r\n    }\r\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\r\n    type += `)${result?.array ?? ''}`\r\n    return formatAbiParameter({\r\n      ...abiParameter,\r\n      type,\r\n    }) as Result\r\n  }\r\n  // Add `indexed` to type if in `abiParameter`\r\n  if ('indexed' in abiParameter && abiParameter.indexed)\r\n    type = `${type} indexed`\r\n  // Return human-readable ABI parameter\r\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\r\n  return type as Result\r\n}\r\n", "import type { AbiEventParameter, AbiParameter } from '../abi.js'\r\nimport type { Join } from '../types.js'\r\nimport {\r\n  type FormatAbiParameter,\r\n  formatAbiParameter,\r\n} from './formatAbiParameter.js'\r\n\r\n/**\r\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\r\n *\r\n * @param abiParameters - ABI parameters\r\n * @returns Human-readable ABI parameters\r\n *\r\n * @example\r\n * type Result = FormatAbiParameters<[\r\n *   // ^? type Result = 'address from, uint256 tokenId'\r\n *   { type: 'address'; name: 'from'; },\r\n *   { type: 'uint256'; name: 'tokenId'; },\r\n * ]>\r\n */\r\nexport type FormatAbiParameters<\r\n  abiParameters extends readonly [\r\n    AbiParameter | AbiEventParameter,\r\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\r\n  ],\r\n> = Join<\r\n  {\r\n    [key in keyof abiParameters]: FormatAbiParameter<abiParameters[key]>\r\n  },\r\n  ', '\r\n>\r\n\r\n/**\r\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\r\n *\r\n * @param abiParameters - ABI parameters\r\n * @returns Human-readable ABI parameters\r\n *\r\n * @example\r\n * const result = formatAbiParameters([\r\n *   //  ^? const result: 'address from, uint256 tokenId'\r\n *   { type: 'address', name: 'from' },\r\n *   { type: 'uint256', name: 'tokenId' },\r\n * ])\r\n */\r\nexport function formatAbiParameters<\r\n  const abiParameters extends readonly [\r\n    AbiParameter | AbiEventParameter,\r\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\r\n  ],\r\n>(abiParameters: abiParameters): FormatAbiParameters<abiParameters> {\r\n  let params = ''\r\n  const length = abiParameters.length\r\n  for (let i = 0; i < length; i++) {\r\n    const abiParameter = abiParameters[i]!\r\n    params += formatAbiParameter(abiParameter)\r\n    if (i !== length - 1) params += ', '\r\n  }\r\n  return params as FormatAbiParameters<abiParameters>\r\n}\r\n", "import type {\r\n  Abi,\r\n  AbiConstructor,\r\n  AbiError,\r\n  AbiEvent,\r\n  AbiEventParameter,\r\n  AbiFallback,\r\n  AbiFunction,\r\n  AbiParameter,\r\n  AbiReceive,\r\n  AbiStateMutability,\r\n} from '../abi.js'\r\nimport {\r\n  type FormatAbiParameters as FormatAbiParameters_,\r\n  formatAbiParameters,\r\n} from './formatAbiParameters.js'\r\nimport type { AssertName } from './types/signatures.js'\r\n\r\n/**\r\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\r\n *\r\n * @param abiItem - ABI item\r\n * @returns Human-readable ABI item\r\n */\r\nexport type FormatAbiItem<abiItem extends Abi[number]> =\r\n  Abi[number] extends abiItem\r\n    ? string\r\n    :\r\n        | (abiItem extends AbiFunction\r\n            ? AbiFunction extends abiItem\r\n              ? string\r\n              : `function ${AssertName<abiItem['name']>}(${FormatAbiParameters<\r\n                  abiItem['inputs']\r\n                >})${abiItem['stateMutability'] extends Exclude<\r\n                  AbiStateMutability,\r\n                  'nonpayable'\r\n                >\r\n                  ? ` ${abiItem['stateMutability']}`\r\n                  : ''}${abiItem['outputs']['length'] extends 0\r\n                  ? ''\r\n                  : ` returns (${FormatAbiParameters<abiItem['outputs']>})`}`\r\n            : never)\r\n        | (abiItem extends AbiEvent\r\n            ? AbiEvent extends abiItem\r\n              ? string\r\n              : `event ${AssertName<abiItem['name']>}(${FormatAbiParameters<\r\n                  abiItem['inputs']\r\n                >})`\r\n            : never)\r\n        | (abiItem extends AbiError\r\n            ? AbiError extends abiItem\r\n              ? string\r\n              : `error ${AssertName<abiItem['name']>}(${FormatAbiParameters<\r\n                  abiItem['inputs']\r\n                >})`\r\n            : never)\r\n        | (abiItem extends AbiConstructor\r\n            ? AbiConstructor extends abiItem\r\n              ? string\r\n              : `constructor(${FormatAbiParameters<\r\n                  abiItem['inputs']\r\n                >})${abiItem['stateMutability'] extends 'payable'\r\n                  ? ' payable'\r\n                  : ''}`\r\n            : never)\r\n        | (abiItem extends AbiFallback\r\n            ? AbiFallback extends abiItem\r\n              ? string\r\n              : `fallback() external${abiItem['stateMutability'] extends 'payable'\r\n                  ? ' payable'\r\n                  : ''}`\r\n            : never)\r\n        | (abiItem extends AbiReceive\r\n            ? AbiReceive extends abiItem\r\n              ? string\r\n              : 'receive() external payable'\r\n            : never)\r\n\r\ntype FormatAbiParameters<\r\n  abiParameters extends readonly (AbiParameter | AbiEventParameter)[],\r\n> = abiParameters['length'] extends 0\r\n  ? ''\r\n  : FormatAbiParameters_<\r\n      abiParameters extends readonly [\r\n        AbiParameter | AbiEventParameter,\r\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\r\n      ]\r\n        ? abiParameters\r\n        : never\r\n    >\r\n\r\n/**\r\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\r\n *\r\n * @param abiItem - ABI item\r\n * @returns Human-readable ABI item\r\n */\r\nexport function formatAbiItem<const abiItem extends Abi[number]>(\r\n  abiItem: abiItem,\r\n): FormatAbiItem<abiItem> {\r\n  type Result = FormatAbiItem<abiItem>\r\n  type Params = readonly [\r\n    AbiParameter | AbiEventParameter,\r\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\r\n  ]\r\n\r\n  if (abiItem.type === 'function')\r\n    return `function ${abiItem.name}(${formatAbiParameters(\r\n      abiItem.inputs as Params,\r\n    )})${\r\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\r\n        ? ` ${abiItem.stateMutability}`\r\n        : ''\r\n    }${\r\n      abiItem.outputs?.length\r\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\r\n        : ''\r\n    }`\r\n  if (abiItem.type === 'event')\r\n    return `event ${abiItem.name}(${formatAbiParameters(\r\n      abiItem.inputs as Params,\r\n    )})`\r\n  if (abiItem.type === 'error')\r\n    return `error ${abiItem.name}(${formatAbiParameters(\r\n      abiItem.inputs as Params,\r\n    )})`\r\n  if (abiItem.type === 'constructor')\r\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\r\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\r\n    }`\r\n  if (abiItem.type === 'fallback')\r\n    return `fallback() external${\r\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\r\n    }` as Result\r\n  return 'receive() external payable' as Result\r\n}\r\n", "import type { Abi } from '../abi.js'\r\nimport { type FormatAbiItem, formatAbiItem } from './formatAbiItem.js'\r\n\r\n/**\r\n * Parses JSON ABI into human-readable ABI\r\n *\r\n * @param abi - ABI\r\n * @returns Human-readable ABI\r\n */\r\nexport type FormatAbi<abi extends Abi | readonly unknown[]> = Abi extends abi\r\n  ? readonly string[]\r\n  : abi extends readonly []\r\n    ? never\r\n    : abi extends Abi\r\n      ? {\r\n          [key in keyof abi]: FormatAbiItem<abi[key]>\r\n        }\r\n      : readonly string[]\r\n\r\n/**\r\n * Parses JSON ABI into human-readable ABI\r\n *\r\n * @param abi - ABI\r\n * @returns Human-readable ABI\r\n */\r\nexport function formatAbi<const abi extends Abi | readonly unknown[]>(\r\n  abi: abi,\r\n): FormatAbi<abi> {\r\n  const signatures = []\r\n  const length = abi.length\r\n  for (let i = 0; i < length; i++) {\r\n    const abiItem = abi[i]!\r\n    const signature = formatAbiItem(abiItem as Abi[number])\r\n    signatures.push(signature)\r\n  }\r\n  return signatures as unknown as FormatAbi<abi>\r\n}\r\n", "/**\r\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\r\n * @todo re-check https://issues.chromium.org/issues/42212588\r\n * @module\r\n */\r\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\r\nconst _32n = /* @__PURE__ */ BigInt(32);\r\n\r\nfunction fromBig(\r\n  n: bigint,\r\n  le = false\r\n): {\r\n  h: number;\r\n  l: number;\r\n} {\r\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\r\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\r\n}\r\n\r\nfunction split(lst: bigint[], le = false): Uint32Array[] {\r\n  let Ah = new Uint32Array(lst.length);\r\n  let Al = new Uint32Array(lst.length);\r\n  for (let i = 0; i < lst.length; i++) {\r\n    const { h, l } = fromBig(lst[i], le);\r\n    [Ah[i], Al[i]] = [h, l];\r\n  }\r\n  return [Ah, Al];\r\n}\r\n\r\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\r\n// for Shift in [0, 32)\r\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\r\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\r\n// Right rotate for Shift in [1, 32)\r\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\r\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\r\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\r\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\r\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\r\n// Right rotate for shift===32 (just swaps l&h)\r\nconst rotr32H = (_h: number, l: number): number => l;\r\nconst rotr32L = (h: number, _l: number): number => h;\r\n// Left rotate for Shift in [1, 32)\r\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\r\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\r\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\r\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\r\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\r\n\r\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\r\n// simple take carry out of low bit sum by shift, we need to use division.\r\nfunction add(\r\n  Ah: number,\r\n  Al: number,\r\n  Bh: number,\r\n  Bl: number\r\n): {\r\n  h: number;\r\n  l: number;\r\n} {\r\n  const l = (Al >>> 0) + (Bl >>> 0);\r\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\r\n}\r\n// Addition with more than 2 elements\r\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\r\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\r\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\r\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\r\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\r\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\r\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\r\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\r\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\r\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\r\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\r\n\r\n// prettier-ignore\r\nexport {\r\n  fromBig, split, toBig,\r\n  shrSH, shrSL,\r\n  rotrSH, rotrSL, rotrBH, rotrBL,\r\n  rotr32H, rotr32L,\r\n  rotlSH, rotlSL, rotlBH, rotlBL,\r\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\r\n};\r\n// prettier-ignore\r\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\r\n  fromBig, split, toBig,\r\n  shrSH, shrSL,\r\n  rotrSH, rotrSL, rotrBH, rotrBL,\r\n  rotr32H, rotr32L,\r\n  rotlSH, rotlSL, rotlBH, rotlBL,\r\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\r\n};\r\nexport default u64;\r\n", "/**\r\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\r\n * Different from older hashes, the internal state is bigger than output size.\r\n *\r\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\r\n * [Website](https://keccak.team/keccak.html),\r\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\r\n *\r\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\r\n * @module\r\n */\r\nimport { abytes, aexists, anumber, aoutput } from './_assert.js';\r\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\r\nimport {\r\n  byteSwap32,\r\n  Hash,\r\n  isLE,\r\n  toBytes,\r\n  u32,\r\n  wrapConstructor,\r\n  wrapXOFConstructorWithOpts,\r\n  type CHash,\r\n  type CHashXO,\r\n  type HashXOF,\r\n  type Input,\r\n} from './utils.js';\r\n\r\n// Various per round constants calculations\r\nconst SHA3_PI: number[] = [];\r\nconst SHA3_ROTL: number[] = [];\r\nconst _SHA3_IOTA: bigint[] = [];\r\nconst _0n = /* @__PURE__ */ BigInt(0);\r\nconst _1n = /* @__PURE__ */ BigInt(1);\r\nconst _2n = /* @__PURE__ */ BigInt(2);\r\nconst _7n = /* @__PURE__ */ BigInt(7);\r\nconst _256n = /* @__PURE__ */ BigInt(256);\r\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\r\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\r\n  // Pi\r\n  [x, y] = [y, (2 * x + 3 * y) % 5];\r\n  SHA3_PI.push(2 * (5 * y + x));\r\n  // Rotational\r\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\r\n  // Iota\r\n  let t = _0n;\r\n  for (let j = 0; j < 7; j++) {\r\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\r\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\r\n  }\r\n  _SHA3_IOTA.push(t);\r\n}\r\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\r\n\r\n// Left rotation (without 0, 32, 64)\r\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\r\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\r\n\r\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\r\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\r\n  const B = new Uint32Array(5 * 2);\r\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\r\n  for (let round = 24 - rounds; round < 24; round++) {\r\n    // Theta \r\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\r\n    for (let x = 0; x < 10; x += 2) {\r\n      const idx1 = (x + 8) % 10;\r\n      const idx0 = (x + 2) % 10;\r\n      const B0 = B[idx0];\r\n      const B1 = B[idx0 + 1];\r\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\r\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\r\n      for (let y = 0; y < 50; y += 10) {\r\n        s[x + y] ^= Th;\r\n        s[x + y + 1] ^= Tl;\r\n      }\r\n    }\r\n    // Rho () and Pi ()\r\n    let curH = s[2];\r\n    let curL = s[3];\r\n    for (let t = 0; t < 24; t++) {\r\n      const shift = SHA3_ROTL[t];\r\n      const Th = rotlH(curH, curL, shift);\r\n      const Tl = rotlL(curH, curL, shift);\r\n      const PI = SHA3_PI[t];\r\n      curH = s[PI];\r\n      curL = s[PI + 1];\r\n      s[PI] = Th;\r\n      s[PI + 1] = Tl;\r\n    }\r\n    // Chi ()\r\n    for (let y = 0; y < 50; y += 10) {\r\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\r\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\r\n    }\r\n    // Iota ()\r\n    s[0] ^= SHA3_IOTA_H[round];\r\n    s[1] ^= SHA3_IOTA_L[round];\r\n  }\r\n  B.fill(0);\r\n}\r\n\r\n/** Keccak sponge function. */\r\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\r\n  protected state: Uint8Array;\r\n  protected pos = 0;\r\n  protected posOut = 0;\r\n  protected finished = false;\r\n  protected state32: Uint32Array;\r\n  protected destroyed = false;\r\n  // NOTE: we accept arguments in bytes instead of bits here.\r\n  constructor(\r\n    public blockLen: number,\r\n    public suffix: number,\r\n    public outputLen: number,\r\n    protected enableXOF = false,\r\n    protected rounds: number = 24\r\n  ) {\r\n    super();\r\n    // Can be passed from user as dkLen\r\n    anumber(outputLen);\r\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\r\n    // 0 < blockLen < 200\r\n    if (0 >= this.blockLen || this.blockLen >= 200)\r\n      throw new Error('Sha3 supports only keccak-f1600 function');\r\n    this.state = new Uint8Array(200);\r\n    this.state32 = u32(this.state);\r\n  }\r\n  protected keccak(): void {\r\n    if (!isLE) byteSwap32(this.state32);\r\n    keccakP(this.state32, this.rounds);\r\n    if (!isLE) byteSwap32(this.state32);\r\n    this.posOut = 0;\r\n    this.pos = 0;\r\n  }\r\n  update(data: Input): this {\r\n    aexists(this);\r\n    const { blockLen, state } = this;\r\n    data = toBytes(data);\r\n    const len = data.length;\r\n    for (let pos = 0; pos < len; ) {\r\n      const take = Math.min(blockLen - this.pos, len - pos);\r\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\r\n      if (this.pos === blockLen) this.keccak();\r\n    }\r\n    return this;\r\n  }\r\n  protected finish(): void {\r\n    if (this.finished) return;\r\n    this.finished = true;\r\n    const { state, suffix, pos, blockLen } = this;\r\n    // Do the padding\r\n    state[pos] ^= suffix;\r\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\r\n    state[blockLen - 1] ^= 0x80;\r\n    this.keccak();\r\n  }\r\n  protected writeInto(out: Uint8Array): Uint8Array {\r\n    aexists(this, false);\r\n    abytes(out);\r\n    this.finish();\r\n    const bufferOut = this.state;\r\n    const { blockLen } = this;\r\n    for (let pos = 0, len = out.length; pos < len; ) {\r\n      if (this.posOut >= blockLen) this.keccak();\r\n      const take = Math.min(blockLen - this.posOut, len - pos);\r\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\r\n      this.posOut += take;\r\n      pos += take;\r\n    }\r\n    return out;\r\n  }\r\n  xofInto(out: Uint8Array): Uint8Array {\r\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\r\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\r\n    return this.writeInto(out);\r\n  }\r\n  xof(bytes: number): Uint8Array {\r\n    anumber(bytes);\r\n    return this.xofInto(new Uint8Array(bytes));\r\n  }\r\n  digestInto(out: Uint8Array): Uint8Array {\r\n    aoutput(out, this);\r\n    if (this.finished) throw new Error('digest() was already called');\r\n    this.writeInto(out);\r\n    this.destroy();\r\n    return out;\r\n  }\r\n  digest(): Uint8Array {\r\n    return this.digestInto(new Uint8Array(this.outputLen));\r\n  }\r\n  destroy(): void {\r\n    this.destroyed = true;\r\n    this.state.fill(0);\r\n  }\r\n  _cloneInto(to?: Keccak): Keccak {\r\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\r\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\r\n    to.state32.set(this.state32);\r\n    to.pos = this.pos;\r\n    to.posOut = this.posOut;\r\n    to.finished = this.finished;\r\n    to.rounds = rounds;\r\n    // Suffix can change in cSHAKE\r\n    to.suffix = suffix;\r\n    to.outputLen = outputLen;\r\n    to.enableXOF = enableXOF;\r\n    to.destroyed = this.destroyed;\r\n    return to;\r\n  }\r\n}\r\n\r\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\r\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\r\n\r\n/** SHA3-224 hash function. */\r\nexport const sha3_224: CHash = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\r\n/** SHA3-256 hash function. Different from keccak-256. */\r\nexport const sha3_256: CHash = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\r\n/** SHA3-384 hash function. */\r\nexport const sha3_384: CHash = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\r\n/** SHA3-512 hash function. */\r\nexport const sha3_512: CHash = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\r\n\r\n/** keccak-224 hash function. */\r\nexport const keccak_224: CHash = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\r\n/** keccak-256 hash function. Different from SHA3-256. */\r\nexport const keccak_256: CHash = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\r\n/** keccak-384 hash function. */\r\nexport const keccak_384: CHash = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\r\n/** keccak-512 hash function. */\r\nexport const keccak_512: CHash = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\r\n\r\nexport type ShakeOpts = { dkLen?: number };\r\n\r\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\r\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\r\n    (opts: ShakeOpts = {}) =>\r\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\r\n  );\r\n\r\n/** SHAKE128 XOF with 128-bit security. */\r\nexport const shake128: CHashXO = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\r\n/** SHAKE256 XOF with 256-bit security. */\r\nexport const shake256: CHashXO = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\r\n"],
  "mappings": "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",
  "names": ["parseAbiParameter", "length"]
}
